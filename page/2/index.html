<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"oneyoung.top","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="无涯">
<meta property="og:url" content="https://oneyoung.top/page/2/index.html">
<meta property="og:site_name" content="无涯">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="oneyoung">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://oneyoung.top/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>无涯</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">无涯</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">无所谓无 无所谓有</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/oneyoungg" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://oneyoung.top/Java%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="oneyoung">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无涯">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97/" class="post-title-link" itemprop="url">Java移位运算</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-29 20:05:10" itemprop="dateCreated datePublished" datetime="2021-01-29T20:05:10+08:00">2021-01-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-01 14:13:47" itemprop="dateModified" datetime="2021-08-01T14:13:47+08:00">2021-08-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在读JDK源码，发现HashMap里面存再大量的逻辑运算，而Java逻辑运算其实在我实际的开发当中用的相当的少，有些甚至还看不太懂，下面记录一些我读源码的时候遇到的一些逻辑运算。</p>
<h2 id="gt-gt-和-gt-gt-gt"><a href="#gt-gt-和-gt-gt-gt" class="headerlink" title="&gt;&gt; 和 &gt;&gt;&gt;"></a>&gt;&gt; 和 &gt;&gt;&gt;</h2><ul>
<li><p><code>&gt;&gt;</code>右移位符，该符号表示将二进制右移一位，不带符号位</p>
</li>
<li><p><code>&gt;&gt;&gt;</code>带符号右移位符，该符号表示将二进制右移一位，带符号位</p>
</li>
</ul>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaLogic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = -<span class="number">10</span>;</span><br><span class="line">        outBinaryString(a);</span><br><span class="line">        outBinaryString(a &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        outBinaryString(a &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">outBinaryString</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%20d --&gt; &quot;</span>, a);</span><br><span class="line">        print(a);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            System.out.print((num &amp; (<span class="number">1</span> &lt;&lt; i)) == <span class="number">0</span> ? <span class="string">&quot;0&quot;</span> : <span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行Main方法打印出如下结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">       -<span class="number">10</span> --&gt; <span class="number">11111111111111111111111111110110</span></span><br><span class="line">        -<span class="number">5</span> --&gt; <span class="number">11111111111111111111111111111011</span></span><br><span class="line"><span class="number">2147483643</span> --&gt; <span class="number">01111111111111111111111111111011</span></span><br></pre></td></tr></table></figure>
<h3 id="相关源码"><a href="#相关源码" class="headerlink" title="相关源码"></a>相关源码</h3><p><code>java.util.HashMap#hash</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://oneyoung.top/%E7%BB%86%E8%AF%BB%E6%BA%90%E7%A0%81%E4%B9%8B-HashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="oneyoung">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无涯">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%BB%86%E8%AF%BB%E6%BA%90%E7%A0%81%E4%B9%8B-HashMap/" class="post-title-link" itemprop="url">细读源码之-HashMap</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-29 16:07:20" itemprop="dateCreated datePublished" datetime="2021-01-29T16:07:20+08:00">2021-01-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-01 14:13:47" itemprop="dateModified" datetime="2021-08-01T14:13:47+08:00">2021-08-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>文章将在我的Git Page更新 <a href="https://oneyoung.top/%E7%BB%86%E8%AF%BB%E6%BA%90%E7%A0%81%E4%B9%8B-HashMap/">原文链接</a></p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大家开发中用得最多的工具类就是JAVA的集合框架了，今天我们来从源码的角度剖析Map集合的实现之一<code>HashMap</code>。</p>
<h2 id="HashMap-简介"><a href="#HashMap-简介" class="headerlink" title="HashMap 简介"></a>HashMap 简介</h2><blockquote>
<p>这里我就直接翻译JDK源码注释了，其实注释讲得很详细了。</p>
</blockquote>
<p>基于哈希表的Map接口的实现。 此实现提供所有可选的映射操作，并允许空值和空键。 （ HashMap类与Hashtable大致等效，不同之处在于它是不同步的，并且允许为null。）此类不保证映射的顺序。 特别是，它不能保证顺序会随着时间的推移保持恒定。<br>假设哈希函数将元素正确分散在存储桶中，则此实现为基本操作（ get和put ）提供恒定时间(这里指时间复杂度为o1)的性能。 集合视图上的迭代所需的时间与HashMap实例的“容量”（存储桶数）及其大小（键-值映射数）成正比。 因此，如果迭代性能很重要，则不要将初始容量设置得过高（或负载因数过低），这一点非常重要。<br>HashMap的实例具有两个影响其性能的参数：初始容量和负载因子。 容量是哈希表中存储桶的数量，初始容量只是创建哈希表时的容量。 负载因子是在自动增加其哈希表容量之前允许哈希表获得的满度的度量。 当哈希表中的条目数超过负载因子和当前容量的乘积时，哈希表将被重新哈希（即，内部数据结构将被重建），因此哈希表的存储桶数约为两倍。<br>通常，默认负载因子（.75）在时间和空间成本之间提供了一个很好的权衡。 较高的值会减少空间开销，但会增加查找成本（在HashMap类的大多数操作中都得到体现，包括get和put ）。 设置其初始容量时，应考虑映射中的预期条目数及其负载因子，以最大程度地减少重新哈希操作的次数。 如果初始容量大于最大条目数除以负载因子，则将不会发生任何哈希操作。<br>如果将许多映射存储在HashMap实例中，则创建具有足够大容量的映射将比让其根据需要增长表的自动重新哈希处理更有效地存储映射。 请注意，使用具有相同hashCode()许多键是降低任何哈希表性能的肯定方法。 为了改善影响，当键为Comparable ，此类可以使用键之间的比较顺序来帮助打破平局。<br>请注意，此实现未同步。 如果多个线程同时访问哈希映射，并且至少有一个线程在结构上修改该映射，则必须在外部进行同步。 （结构修改是添加或删除一个或多个映射的任何操作；仅更改与实例已经包含的键相关联的值不是结构修改。）通常通过在自然封装了Map的某个对象上进行同步来实现。 。 如果不存在这样的对象，则应使用Collections.synchronizedMap方法“包装”Map。 最好在创建时完成此操作，以防止意外不同步地访问Map：<br>     Map m = Collections.synchronizedMap(new HashMap(…));<br>该类的所有“集合视图方法”返回的迭代器都是快速失败的：如果在创建迭代器后的任何ff时间以任何方式对Map进行结构修改，则除了通过迭代器自己的remove方法之外，迭代器都会抛出ConcurrentModificationException 。 因此，面对并发修改，迭代器会快速干净地失败，而不会在未来的不确定时间冒着任意，不确定的行为的风险。<br>请注意，迭代器的快速失败行为无法得到保证，因为通常来说，在存在不同步的并发修改的情况下，不可能做出任何严格的保证。 快速失败的迭代器会尽最大努力抛出ConcurrentModificationException 。 因此，编写依赖于此异常的程序的正确性是错误的：迭代器的快速失败行为应仅用于检测错误。<br>此类是Java Collections Framework的成员</p>
<h2 id="几个重要的成员变量"><a href="#几个重要的成员变量" class="headerlink" title="几个重要的成员变量"></a>几个重要的成员变量</h2><ul>
<li><code>Node&lt;K,V&gt;[]  table </code>  核心数据结构 数组 + 链表</li>
<li><code>int size</code> 集合的大小</li>
<li><code>int modCount</code> 被修改的次数</li>
<li><code>int threshold</code> 下一个要调整大小的大小值（容量 * 负载因子)</li>
<li><code>float loadFactor</code> 负载因子</li>
<li><code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet</code> KV集</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p><code>HashMap</code> 有多个重载构造方法，但最终都会去掉下面这个构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有两个参数</p>
<ul>
<li>initialCapacity 初始容量</li>
<li>loadFactor 负载因子</li>
</ul>
<p><code>HashMap</code>就是对<code>散列表</code>这种数据结构的实现，所以需要这个两个参数去定义<code>散列表</code></p>
<h3 id="tableSizeFor"><a href="#tableSizeFor" class="headerlink" title="tableSizeFor"></a>tableSizeFor</h3><p>我们从上面的构造方法可以看出，<code>HashMap</code>在初始化的时候，会调用这个方法去计算实际初始化的容量并暂存为<code>threshold</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法返回<strong>大于输入参数且最近的2的整数次幂的数</strong>。比如10，则返回16。</p>
<p>先来分析有关n位操作部分：先来假设n的二进制为01xxx…xxx。接着</p>
<ul>
<li><p>对n右移1位：001xx…xxx，再位或：011xx…xxx</p>
</li>
<li><p>对n右移2为：00011…xxx，再位或：01111…xxx</p>
</li>
<li><p>此时前面已经有四个1了，再右移4位且位或可得8个1</p>
</li>
<li><p>同理，有8个1，右移8位肯定会让后八位也为1。</p>
</li>
</ul>
<p>综上可得，该算法让最高位的1后面的位全变为1。</p>
<p>最后再让结果n+1，即得到了2的整数次幂的值了。</p>
<p>现在回来看看第一条语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>让<code>cap - 1</code>再赋值给n的目的是另找到的目标值大于或<strong>等于</strong>原值。例如二进制1000，十进制数值为8。如果不对它减1而直接操作，将得到答案10000，即16。显然不是结果。减1后二进制为111，再进行操作则会得到原来的数值1000，即8。</p>
<p>这种方法的效率非常高，可见Java8对容器优化了很多</p>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里是取hash的高16位与hash值进行异或运算，因为在进行槽位计算的时候容易丢失高位的特征，所以采取低位与高位进行运算获得一个结果，保留了高位与低位的特征。如果采用<code>|</code>将会使位偏向1，如果采用<code>&amp;</code>将会偏向0，而采用<code>^</code>则没有明显的偏向性。</p>
<p>槽位计算源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tab[i = (n - <span class="number">1</span>) &amp; hash]</span><br></pre></td></tr></table></figure>
<h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法将元素加入散列表，具体实现是下面这个<code>putVal</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.put and related methods.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent if true, don&#x27;t change existing value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>明确几个局部变量的意义</p>
<ul>
<li><code>Node&lt;K,V&gt;[] tab</code> 散列表</li>
<li><code>Node&lt;K,V&gt; p</code> 新增的节点</li>
<li><code>int n</code> 散列表数组的长度</li>
<li><code>int i</code> 计算出的槽位</li>
</ul>
<p>我们跟随源码的流程进行分析</p>
<p>首先判断散列表是否有被创建出来，如果没有创建，则进行散列表的初始化。这是一种懒加载策略。初始化的过程我们下面再分析。</p>
<p>然后就是计算散列位置，判断该位置上是否有元素。若没有则直接把元素放入。如果该节点上有元素了，则发生了hash碰撞，需要另外的处理。</p>
<p>下面分析一下槽点计算的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = (n - <span class="number">1</span>) &amp; hash</span><br></pre></td></tr></table></figure>
<p>将容量-1与hash值进行与运算。由于散列表在初始化的时候，容量是2的次幂，所以在减一之后，二进制位都变为了1，再与hash值进行与运算其实就是取余数，这个就相当于<code>hash % n</code> 。但是效率确比取模运算高出很多。</p>
<p>如果发生了hash碰撞，则首先会进行<code>key</code>是否一致导致的，如果key不等发生的hash碰撞，则会吧当前元素放在链表的下一个节点，如果链表长度超过8，则会树化处理，变为红黑树。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://oneyoung.top/IDEA%E6%8F%92%E4%BB%B6-Rainbow-Brackets/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="oneyoung">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无涯">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/IDEA%E6%8F%92%E4%BB%B6-Rainbow-Brackets/" class="post-title-link" itemprop="url">IDEA插件 Rainbow Brackets</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-26 19:04:34" itemprop="dateCreated datePublished" datetime="2021-01-26T19:04:34+08:00">2021-01-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-01 14:13:47" itemprop="dateModified" datetime="2021-08-01T14:13:47+08:00">2021-08-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/IDEA%E6%8F%92%E4%BB%B6-Rainbow-Brackets/image-20210126190839451.png" alt="image-20210126190839451"></p>
<p>一个小插件，可以使你的括号变色。</p>
<p>既美观，也可以避免一些错误。</p>
<p>我表示相见恨晚</p>
<p>附上插件首页</p>
<p><a target="_blank" rel="noopener" href="https://plugins.jetbrains.com/plugin/10080-rainbow-brackets">https://plugins.jetbrains.com/plugin/10080-rainbow-brackets</a></p>
<h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>我们来看下这个方法的源码<code>java.util.Map#getOrDefault</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">    V v;</span><br><span class="line">    <span class="keyword">return</span> (((v = get(key)) != <span class="keyword">null</span>) || containsKey(key))</span><br><span class="line">        ? v</span><br><span class="line">        : defaultValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这括号是不是看得人头都晕掉了，安装彩虹括号后就变得很清晰了</p>
<p><img src="/IDEA%E6%8F%92%E4%BB%B6-Rainbow-Brackets/image-20210129153934682.png" alt="image-20210129153934682"></p>
<p>通过颜色标注，关系就很清晰了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://oneyoung.top/Spring-Bean-%E6%B3%A8%E8%A7%A3%E6%B3%A8%E5%85%A5%E5%91%BD%E5%90%8D%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="oneyoung">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无涯">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Spring-Bean-%E6%B3%A8%E8%A7%A3%E6%B3%A8%E5%85%A5%E5%91%BD%E5%90%8D%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Spring Bean 注解注入命名源码分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-20 22:25:09" itemprop="dateCreated datePublished" datetime="2021-01-20T22:25:09+08:00">2021-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-01 14:13:47" itemprop="dateModified" datetime="2021-08-01T14:13:47+08:00">2021-08-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上篇文章讲到了XML配置方式在不指定<code>ID</code>的情况下，Spring的<code>BeanName</code>。今天来谈论下，现代Spring中Bean注册使用最多的方式—<code>注解</code>。注解方式生成的<code>BeanName</code>策略又是怎样的呢。</p>
<h2 id="Spring-常用注册Bean注解"><a href="#Spring-常用注册Bean注解" class="headerlink" title="Spring 常用注册Bean注解"></a>Spring 常用注册Bean注解</h2><ul>
<li><code>@Component</code>、<code>@Service</code>、<code>@Repository</code>、<code>@Controller</code> 这四个注解用于类上，实质上是一样的，能够注册当前类到容器，<code>value</code>属性就是<code>BeanName</code></li>
<li><code>@Configuration</code>这个注解同样用作类上，不同的是，这个注解通常与<code>@Bean</code>配合使用，注册方法的返回类型对象，用作配置。</li>
<li><code>@Bean</code> 用于方法上，该方法需要在<code>@Configuration</code>标注的类里面，且方法必须为<code>public</code></li>
</ul>
<h2 id="AnnotationBeanNameGenerator"><a href="#AnnotationBeanNameGenerator" class="headerlink" title="AnnotationBeanNameGenerator"></a>AnnotationBeanNameGenerator</h2><p><code>@Component</code>、<code>@Service</code>、<code>@Repository</code>、<code>@Controller</code> 、<code>@Configuration</code></p>
<p>这五个注解注册的Bean名称都由<code>AnnotationBeanNameGenerator</code>生成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationBeanNameGenerator</span> <span class="keyword">implements</span> <span class="title">BeanNameGenerator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * A convenient constant for a default &#123;<span class="doctag">@code</span> AnnotationBeanNameGenerator&#125; instance,</span></span><br><span class="line"><span class="comment">  * as used for component scanning purposes.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@since</span> 5.2</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> AnnotationBeanNameGenerator INSTANCE = <span class="keyword">new</span> AnnotationBeanNameGenerator();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String COMPONENT_ANNOTATION_CLASSNAME = <span class="string">&quot;org.springframework.stereotype.Component&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">generateBeanName</span><span class="params">(BeanDefinition definition, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (definition <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">   String beanName = determineBeanNameFromAnnotation((AnnotatedBeanDefinition) definition);</span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasText(beanName)) &#123;</span><br><span class="line">    <span class="comment">// Explicit bean name found.</span></span><br><span class="line">    <span class="keyword">return</span> beanName;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Fallback: generate a unique default bean name.</span></span><br><span class="line">  <span class="keyword">return</span> buildDefaultBeanName(definition, registry);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该生成器同样实现了父类<code>BeanNameGenerator</code>的<code>generateBeanName</code>方法，与默认实现不同的是没有委托给其它类实现功能，而在自身实现，同样存在一个单列对象。</p>
<p>可以看到命名逻辑先是从注解的元信息获取配置的<code>BeanName</code>,在获取不到的情况下回去调用<code>buildDefaultBeanName</code>生成一个名称。</p>
<p>下面我们看下生成逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Derive a default bean name from the given bean definition.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The default implementation delegates to &#123;<span class="doctag">@link</span> #buildDefaultBeanName(BeanDefinition)&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> definition the bean definition to build a bean name for</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> registry the registry that the given bean definition is being registered with</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the default bean name (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">buildDefaultBeanName</span><span class="params">(BeanDefinition definition, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> buildDefaultBeanName(definition);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Derive a default bean name from the given bean definition.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The default implementation simply builds a decapitalized version</span></span><br><span class="line"><span class="comment"> * of the short class name: e.g. &quot;mypackage.MyJdbcDao&quot; -&gt; &quot;myJdbcDao&quot;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that inner classes will thus have names of the form</span></span><br><span class="line"><span class="comment"> * &quot;outerClassName.InnerClassName&quot;, which because of the period in the</span></span><br><span class="line"><span class="comment"> * name may be an issue if you are autowiring by name.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> definition the bean definition to build a bean name for</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the default bean name (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">buildDefaultBeanName</span><span class="params">(BeanDefinition definition)</span> </span>&#123;</span><br><span class="line"> String beanClassName = definition.getBeanClassName();</span><br><span class="line"> Assert.state(beanClassName != <span class="keyword">null</span>, <span class="string">&quot;No bean class name set&quot;</span>);</span><br><span class="line"> String shortClassName = ClassUtils.getShortName(beanClassName);</span><br><span class="line"> <span class="keyword">return</span> Introspector.decapitalize(shortClassName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>该方法委托给另外一个重载方法实现，先获取该Bean的<code>ClassName</code>,然后获取短的命称，即类名，最后<code>decapitalize</code>把类名首字母变为小写。</p>
<p>使用采用这种方式生成的<code>BeanName</code>就是类名首字母小写。例如<code>com.oneyoung.User -&gt; user</code></p>
<h2 id="Bean-名称生成策略"><a href="#Bean-名称生成策略" class="headerlink" title="@Bean 名称生成策略"></a>@Bean 名称生成策略</h2><p>使用<code>@Bean</code>方式注册到容器的命名方式与上面有所不同。</p>
<p>加载实现类是<code>ConfigurationClassBeanDefinitionReader</code>专门用来处理配置类的Bean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AnnotationAttributes bean = AnnotationConfigUtils.attributesFor(metadata, Bean.class);</span><br><span class="line">Assert.state(bean != <span class="keyword">null</span>, <span class="string">&quot;No @Bean annotation attributes&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Consider name and any aliases</span></span><br><span class="line">List&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(bean.getStringArray(<span class="string">&quot;name&quot;</span>)));</span><br><span class="line">String beanName = (!names.isEmpty() ? names.remove(<span class="number">0</span>) : methodName);</span><br></pre></td></tr></table></figure>
<p>这部分代码可以看出，先去注解的value配置，如果为空则取方法名。所以默认的<code>beanName</code>就是方法名。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://oneyoung.top/Spring-Bean-%E5%91%BD%E5%90%8D%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="oneyoung">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无涯">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Spring-Bean-%E5%91%BD%E5%90%8D%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Spring Bean 命名源码分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-19 23:05:22" itemprop="dateCreated datePublished" datetime="2021-01-19T23:05:22+08:00">2021-01-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-01 14:13:47" itemprop="dateModified" datetime="2021-08-01T14:13:47+08:00">2021-08-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Spring在进行Bean注册的时候需要有一个唯一标识，这个标识也成为<code>BeanName</code>。在进行Bean注册时，这个<code>id</code>并不必填项，它可以由Spring自动生成。下面就来讨论其中一种生成策略。</p>
<h2 id="BeanNameGenerator"><a href="#BeanNameGenerator" class="headerlink" title="BeanNameGenerator"></a>BeanNameGenerator</h2><p><code>org.springframework.beans.factory.support.BeanNameGenerator</code>这个接口就是Spring Bean名称生成器。我们看下源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanNameGenerator</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Generate a bean name for the given bean definition.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> definition the bean definition to generate a name for</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> registry the bean definition registry that the given definition</span></span><br><span class="line"><span class="comment">	 * is supposed to be registered with</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the generated bean name</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">String <span class="title">generateBeanName</span><span class="params">(BeanDefinition definition, BeanDefinitionRegistry registry)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>该接口只定义了一个方法用于获取BeanName，需要传入<code>BeanDefinition</code> <code>BeanDefinitionRegistry</code></p>
<p>这里简单说明下为什么需要这两个参数</p>
<ul>
<li><code>BeanDefinition</code>用于获取该Bean的<code>ClassName</code></li>
<li><code>BeanDefinitionRegistry</code>用于判断生成的<code>BeanName</code>是否已注册，如果已注册会附加类似<code>#0</code>这样的序列号</li>
</ul>
<h2 id="BeanNameGenerator-实现类"><a href="#BeanNameGenerator-实现类" class="headerlink" title="BeanNameGenerator 实现类"></a>BeanNameGenerator 实现类</h2><p>这个接口有两个实现 <code>DefaultBeanNameGenerator</code> <code>AnnotationBeanNameGenerator</code></p>
<p>这里我们暂时只讨论前者，这个名称生成器的默认实现</p>
<h2 id="DefaultBeanNameGenerator"><a href="#DefaultBeanNameGenerator" class="headerlink" title="DefaultBeanNameGenerator"></a>DefaultBeanNameGenerator</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Default implementation of the &#123;<span class="doctag">@link</span> BeanNameGenerator&#125; interface, delegating to</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> BeanDefinitionReaderUtils#generateBeanName(BeanDefinition, BeanDefinitionRegistry)&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.0.3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultBeanNameGenerator</span> <span class="keyword">implements</span> <span class="title">BeanNameGenerator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * A convenient constant for a default &#123;<span class="doctag">@code</span> DefaultBeanNameGenerator&#125; instance,</span></span><br><span class="line"><span class="comment">	 * as used for &#123;<span class="doctag">@link</span> AbstractBeanDefinitionReader&#125; setup.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 5.2</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultBeanNameGenerator INSTANCE = <span class="keyword">new</span> DefaultBeanNameGenerator();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">generateBeanName</span><span class="params">(BeanDefinition definition, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> BeanDefinitionReaderUtils.generateBeanName(definition, registry);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个默认实现类，存在一个单例对象，看doc是5.2才加的，因为要兼容之前的版本，所以没有私有化构造器</p>
<p>该实现类，委托给<code>BeanDefinitionReaderUtils</code>实现功能</p>
<h2 id="BeanDefinitionReaderUtils"><a href="#BeanDefinitionReaderUtils" class="headerlink" title="BeanDefinitionReaderUtils"></a>BeanDefinitionReaderUtils</h2><p>真正的实现是这个工具类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">generateBeanName</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		BeanDefinition definition, BeanDefinitionRegistry registry, <span class="keyword">boolean</span> isInnerBean)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">	String generatedBeanName = definition.getBeanClassName();</span><br><span class="line">	<span class="keyword">if</span> (generatedBeanName == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (definition.getParentName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">			generatedBeanName = definition.getParentName() + <span class="string">&quot;$child&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (definition.getFactoryBeanName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">			generatedBeanName = definition.getFactoryBeanName() + <span class="string">&quot;$created&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!StringUtils.hasText(generatedBeanName)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">&quot;Unnamed bean definition specifies neither &quot;</span> +</span><br><span class="line">				<span class="string">&quot;&#x27;class&#x27; nor &#x27;parent&#x27; nor &#x27;factory-bean&#x27; - can&#x27;t generate bean name&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	String id = generatedBeanName;</span><br><span class="line">	<span class="keyword">if</span> (isInnerBean) &#123;</span><br><span class="line">		<span class="comment">// Inner bean: generate identity hashcode suffix.</span></span><br><span class="line">		id = generatedBeanName + GENERATED_BEAN_NAME_SEPARATOR + ObjectUtils.getIdentityHexString(definition);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Top-level bean: use plain class name with unique suffix if necessary.</span></span><br><span class="line">		<span class="keyword">return</span> uniqueBeanName(generatedBeanName, registry);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>这里可以看出id是直接取的Bean的ClassName，如果是非内部类，会做唯一性校验</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">uniqueBeanName</span><span class="params">(String beanName, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">	String id = beanName;</span><br><span class="line">	<span class="keyword">int</span> counter = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Increase counter until the id is unique.</span></span><br><span class="line">	<span class="keyword">while</span> (counter == -<span class="number">1</span> || registry.containsBeanDefinition(id)) &#123;</span><br><span class="line">		counter++;</span><br><span class="line">		id = beanName + GENERATED_BEAN_NAME_SEPARATOR + counter;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>每个beanName都会被加上#0，然后去容器里面看是否被注册，如果被组成则序号加一</p>
<blockquote>
<p>写得比较粗糙，有时间会详细写一下</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://oneyoung.top/Windows-Terminal/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="oneyoung">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无涯">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Windows-Terminal/" class="post-title-link" itemprop="url">Windows Terminal</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-29 18:32:20" itemprop="dateCreated datePublished" datetime="2020-12-29T18:32:20+08:00">2020-12-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-01 14:13:47" itemprop="dateModified" datetime="2021-08-01T14:13:47+08:00">2021-08-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>效果图</li>
</ul>
<p><img src="https://s3.ax1x.com/2020/12/29/rbhazq.png" alt="rbhazq.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://oneyoung.top/%E4%BD%A0%E6%89%80%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="oneyoung">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无涯">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E4%BD%A0%E6%89%80%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">你所不知道的单例模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-28 12:29:34" itemprop="dateCreated datePublished" datetime="2020-12-28T12:29:34+08:00">2020-12-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-01 14:13:47" itemprop="dateModified" datetime="2021-08-01T14:13:47+08:00">2021-08-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>单例模式是 Java 设计模式中最简单的一种，只需要一个类就能实现单例模式，但是，你可不能小看单例模式，虽然从设计上来说它比较简单，但是在实现当中你会遇到非常多的坑，所以，系好安全带，上车。</p>
<h2 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h2><p><code>单例模式（Singleton）</code>就是一个类在程序运行中只实例化一次，创建一个全局唯一对象，有点像 Java 的静态变量，但是单例模式要优于静态变量，静态变量在程序启动的时候<code>JVM</code>就会进行加载，如果不使用，会造成大量的资源浪费。单例模式能够实现<code>懒加载</code>，能够在使用实例的时候才去创建实例。开发工具类库中的很多工具类都应用了单例模式，比如线程池、缓存、日志对象等，它们都只需要创建一个对象。</p>
<p>在开发中，会经常遇到一个全局使用的类频繁地创建与销毁，这会非常浪费系统的内存资源，而且容易导致错误甚至一定会产生错误，所以我们单例模式所期待的目标或者说使用它的目的，是为了尽可能的节约内存空间，减少无谓的<code>GC</code>消耗，并且使应用可以正常运作。</p>
<h2 id="如何实现单例模式"><a href="#如何实现单例模式" class="headerlink" title="如何实现单例模式"></a>如何实现单例模式</h2><ul>
<li>静态并私有化实例对象</li>
<li>提供一个公共的静态方法访问私有的静态实例，用来返回唯一实例对象</li>
<li>私有化构造方法，禁止通过构造方法创建实例</li>
</ul>
<h2 id="单例有什么好处"><a href="#单例有什么好处" class="headerlink" title="单例有什么好处"></a>单例有什么好处</h2><ul>
<li>只有一个对象，内存开支少、性能好</li>
<li>避免对资源的多重占用</li>
<li>在系统设置全局访问点，优化和共享资源访问</li>
</ul>
<h2 id="以下介绍常见的几种单例模式实现方式"><a href="#以下介绍常见的几种单例模式实现方式" class="headerlink" title="以下介绍常见的几种单例模式实现方式"></a>以下介绍常见的几种单例模式实现方式</h2><blockquote>
<p>单例模式的写法有饿汉模式、懒汉模式、双重检查锁模式、静态内部类单例模式、枚举类实现单例模式五种方式，其中懒汉模式、双重检查锁模式，如果你写法不当，在多线程情况下会存在不是单例或者单例出异常等问题，具体的原因，在后面的对应处会进行说明。我们从最基本的饿汉模式开始我们的单例编写之路。</p>
</blockquote>
<h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><p>所谓饿汉，自然是非常迫切获取<code>食物</code>，这里的<code>食物</code>所指的自然就是我们的单例对象了。饿汉模式是已一种简单粗暴的方式创建单例对象，在定义静态属性时，直接实例化了对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonObjectHunger</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有静态实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonObjectHunger INSTANCE = <span class="keyword">new</span> SingletonObjectHunger();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有化构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonObjectHunger</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供公开获取实例接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 单例对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonObjectHunger <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>由于使用了<code>static</code>关键字，保证了在引用这个变量时，关于这个变量的所以写入操作都完成，所以保证了JVM层面的线程安全</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>没有实现<code>懒加载</code>的效果，如果一个类比较大，我们在初始化的时就加载了这个类，但是如果我们没有使用这个类，这就导致了内存空间的浪费。</li>
</ul>
<h3 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h3><p>所谓懒汉，就是以偷懒的方式创建单例。这种方式在类初始化的时候不会创建实例，只有在获取使用实例的时候才会创建实例，这样就解决了饿汉模式的空间浪费问题，但是也引入了其他问题。下面介绍一种懒汉模式的写法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonObjectLazy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有静态实例 未初始化实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonObjectLazy instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有化构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonObjectLazy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供公开获取实例接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 单例对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonObjectLazy <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 先判断实例是否为空，如果实例为空，则实例化对象</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonObjectLazy();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是一种懒汉模式的实现方式，但在多线程情况是线程不安全的。这种写法保证不了单列模式，可能出现多实例的情况。下面分析出现多实例的原因</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="number">2</span>     instance = <span class="keyword">new</span> SingletonObjectLazy();</span><br></pre></td></tr></table></figure>
<p>问题就出在上面这个代码片段内。假设有两个线程同时进入到 1 这个位置，因为没有任何资源保护措施，所以两个线程可以同时判断的<code>instance</code>都为空，都将去执行 2 的实例化代码，这样就实例化了两份实例，所以会出现多份实例的情况。</p>
<p>通过上面的分析我们已经知道出现多份实例的原因，如果我们在创建实例的时候进行资源保护，不就可以解决多份实例的问题了吗？确实如此，我们给<code>getInstance()</code>方法加上<code>synchronized</code>关键字，使得<code>getInstance()</code>方法成为同步方法，能够解决多份实例的问题。加上<code>synchronized</code>关键字之后代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> SingletonObjectLazy <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br></pre></td></tr></table></figure>
<p>这样，在某一时刻永远只会有一个线程能执行这个方法，初始化完毕后，其他线程直接获取这个实例。这样似乎解决了线程安全问题。但是同样引入了一个新的问题，加锁之后会使得程序变成串行化，只有抢到锁的线程才能去执行这段代码块，这会使得系统的并发性能大大下降。</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li>避免了饿汉模式的缺点，实现了懒加载，节约了内存空间</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>在不加锁的情况下，线程不安全，可能出现多份实例</li>
<li>在加锁的情况下，使程序串行化，导致系统存在严重并发性能问题</li>
</ul>
<h3 id="双重检查锁模式"><a href="#双重检查锁模式" class="headerlink" title="双重检查锁模式"></a>双重检查锁模式</h3><p>再来讨论一下懒汉模式中加锁的问题，对于<code>getInstance()</code>方法来说，绝大部分的操作都是读操作，读操作是线程安全的，所以我们没必让每个线程必须持有锁才能调用该方法，我们需要去除这个同步锁。由此也产生了一种新的实现模式：<strong>双重检查锁模式</strong>。这种模式完美解决了上面的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonObjectCheck</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义静态变量时，未初始化实例</span></span><br><span class="line"><span class="comment">     * 要解决双重检查锁模式带来空指针异常的问题，只需要使用volatile关键字，volatile关键字严格遵循happens-before原则，即在读操作前，写操作必须全部完成。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SingletonObjectCheck instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有化构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonObjectCheck</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonObjectCheck <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 使用时，先判断实例是否为空，如果实例为空，则实例化对象</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 使用互斥锁 只允许单一线程初始化实例</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonObjectCheck.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonObjectCheck();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种写法在去除了方法上的同步锁，采用互斥锁去创建实例。假设同时有两个线程通过了第一次检查，进入到了互斥锁，线程A获取到这个锁，线程B则阻塞等待。线程A执行初始化对象后，释放锁。线程B获得锁，由于有二次检查，实例已初始化就不会去再次初始化对象。</p>
<blockquote>
<p>扩展：上面的双重检测锁模式看上去完美无缺，其实是存在问题，在多线程的情况下，可能会出现<strong>空指针问题</strong>，出现问题的原因是JVM在实例化对象的时候会进行优化和<code>指令重排</code>操作。如果构造函数中操作比较多时，为了提升效率，JVM 会在构造函数里面的属性未全部完成实例化时，就返回对象。双重检测锁出现空指针问题的原因就是出现在这里，当某个线程获取锁进行实例化时，其他线程就直接获取实例使用，由于JVM指令重排序的原因，其他线程获取的对象也许不是一个完整的对象，所以在使用实例的时候就会出现空指针异常问题。</p>
<p>关于<code>指令重排</code>，感兴趣的同学可以自行了解。</p>
</blockquote>
<p>添加<code>volatile</code>关键字之后的双重检查锁模式就比较完美了，能够保证在多线程的情况下线程安全也不会有性能问题。</p>
<h3 id="静态内部类单例模式"><a href="#静态内部类单例模式" class="headerlink" title="静态内部类单例模式"></a>静态内部类单例模式</h3><blockquote>
<p>静态内部类不依赖外部类，是一种很特殊的内部类。在创建静态内部类的时候，不需要外部类对象的引用。你可以把它当做顶级类。</p>
</blockquote>
<p>静态内部类单例模式也称单例持有者模式，实例由内部类创建，由于 JVM 在加载外部类的过程中, 是不会加载静态内部类的, 只有静态内部类的属性/方法被调用时才会被加载, 并初始化其静态属性。静态属性由<code>static</code>修饰，保证只被实例化一次，并且严格保证实例化顺序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonObjectStaticInner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有化构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonObjectStaticInner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单列持有者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonObjectStaticInner INSTANCE = <span class="keyword">new</span> SingletonObjectStaticInner();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonObjectStaticInner <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InstanceHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里静态内部类为私有，只有这个外部类能访问。这种方法不仅能确保线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。</p>
<h3 id="枚举类实现单例模式"><a href="#枚举类实现单例模式" class="headerlink" title="枚举类实现单例模式"></a>枚举类实现单例模式</h3><p>枚举类实现单例模式是 <code>effective java</code> 作者极力推荐的单例实现模式，因为枚举类型是线程安全的，并且只会装载一次，设计者充分的利用了枚举的这个特性来实现单例模式，枚举的写法非常简单，而且枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonObjectEnum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有化构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonObjectEnum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个静态枚举类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">enum</span> <span class="title">SingletonEnum</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建一个枚举对象，该对象天生为单例</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        INSTANCE;</span><br><span class="line">        <span class="keyword">private</span> SingletonObjectEnum SingletonObjectEnum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 私有化枚举的构造函数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">SingletonEnum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            SingletonObjectEnum = <span class="keyword">new</span> SingletonObjectEnum();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> SingletonObjectEnum <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> SingletonObjectEnum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonObjectEnum <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonEnum.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的静态枚举内部类与之前的静态内部类都是静态内部类，不依赖外部类。枚举值天生为单例，保证了实例的唯一性，私有化枚举构造函数，阻止再次实例化。</p>
<h2 id="扩展：破坏单例模式的方法及解决办法"><a href="#扩展：破坏单例模式的方法及解决办法" class="headerlink" title="扩展：破坏单例模式的方法及解决办法"></a>扩展：破坏单例模式的方法及解决办法</h2><ul>
<li>除枚举方式外, 其他方法都会通过反射的方式破坏单例,反射是通过调用构造方法生成新的对象，所以如果我们想要阻止单例破坏，可以在构造方法中进行判断，若已有实例, 则阻止生成新的实例，解决办法如下:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">SingletonObject</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance !=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;实例已经存在，请勿重复初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果单例类实现了序列化接口Serializable, 就可以通过反序列化破坏单例，所以我们可以不实现序列化接口,如果非得实现序列化接口，可以重写反序列化方法readResolve(), 反序列化时直接返回相关单例对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://oneyoung.top/Elasticsearch-Guide/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="oneyoung">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无涯">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Elasticsearch-Guide/" class="post-title-link" itemprop="url">Elasticsearch Guide</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-28 10:15:49" itemprop="dateCreated datePublished" datetime="2020-12-28T10:15:49+08:00">2020-12-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-01 14:13:47" itemprop="dateModified" datetime="2021-08-01T14:13:47+08:00">2021-08-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Elasticsearch-introduction"><a href="#Elasticsearch-introduction" class="headerlink" title="Elasticsearch introduction"></a><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/elasticsearch-intro.html">Elasticsearch introduction</a></h1><h2 id="Index-some-documents"><a href="#Index-some-documents" class="headerlink" title="Index some documents"></a><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/getting-started-index.html">Index some documents</a></h2><p>集群启动并运行后，您就可以为一些数据建立索引了。 Elasticsearch有多种摄取选项，但最终它们都做同样的事情：将JSON文档放入Elasticsearch索引中。</p>
<p>您可以使用简单的PUT请求直接执行此操作，该请求指定要添加文档的索引，唯一的文档ID，以及请求正文中的一个或多个<code>&quot;field&quot;</code>: <code>&quot;value&quot;</code>对：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUT /customer/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;John Doe&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该请求（如果尚不存在）将自动创建<code>customer</code>索引，添加ID为<code>1</code>的新文档，并存储<code>name</code>字段并为其建立索引。</p>
<p>由于这是一个新document，因此响应显示该操作的结果是创建了该document的版本1：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;customer&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;result&quot;</span> : <span class="string">&quot;created&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;_seq_no&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;_primary_term&quot;</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以从群集中的任何节点立即获得新文档。您可以使用指定其文档ID的GET请求检索它：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /customer/_doc/1</span><br></pre></td></tr></table></figure>
<p>该响应表明找到了具有指定ID的document，并显示了已建立索引的原始源字段。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;customer&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;_seq_no&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;_primary_term&quot;</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;found&quot;</span> : <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;_source&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;John Doe&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要索引的文档很多，则可以使用<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/docs-bulk.html">bulk API</a>批量提交它们。 使用批量处理批处理文档操作比单独提交请求要快得多，因为它可以最大程度地减少网络往返次数。</p>
<p>最佳批处理大小取决于许多因素：文档大小和复杂性，索引编制和搜索负载以及群集可用的资源。 一个好的起点是批处理1,000至5,000个文档，总有效负载在5MB至15MB之间。 从那里，您可以尝试找到最佳位置。</p>
<p>要将一些数据导入Elasticsearch，您可以开始搜索和分析：</p>
<ol>
<li><p>下载<a target="_blank" rel="noopener" href="https://github.com/elastic/elasticsearch/blob/master/docs/src/test/resources/accounts.json?raw=true"><code>accounts.json</code></a>示例数据集。 此随机生成的数据集中的文档代表具有以下信息的用户帐户：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;account_number&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;balance&quot;</span>: <span class="number">16623</span>,</span><br><span class="line">    <span class="attr">&quot;firstname&quot;</span>: <span class="string">&quot;Bradshaw&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;lastname&quot;</span>: <span class="string">&quot;Mckenzie&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;age&quot;</span>: <span class="number">29</span>,</span><br><span class="line">    <span class="attr">&quot;gender&quot;</span>: <span class="string">&quot;F&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;address&quot;</span>: <span class="string">&quot;244 Columbus Place&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;employer&quot;</span>: <span class="string">&quot;Euron&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;email&quot;</span>: <span class="string">&quot;bradshawmckenzie@euron.com&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;city&quot;</span>: <span class="string">&quot;Hobucken&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;state&quot;</span>: <span class="string">&quot;CO&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用以下_bulk请求将帐户数据索引到银行索引中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -H &quot;Content-Type: application&#x2F;json&quot; -XPOST &quot;localhost:9200&#x2F;bank&#x2F;_bulk?pretty&amp;refresh&quot; --data-binary &quot;@accounts.json&quot;</span><br><span class="line">curl &quot;localhost:9200&#x2F;_cat&#x2F;indices?v&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>响应表明成功索引了1,000个文档。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">health status index uuid                   pri rep docs.count docs.deleted store.size pri.store.size</span><br><span class="line">yellow open   bank  l7sSYV2cQXmu6_4rJWVIww   5   1       1000            0    128.6kb        128.6kb</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="Start-searching"><a href="#Start-searching" class="headerlink" title="Start searching"></a><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/getting-started-search.html">Start searching</a></h2><p>将一些数据摄取到Elasticsearch索引后，您可以通过将请求发送到<code>_search</code>端点来进行搜索。要访问全套搜索功能，请使用Elasticsearch Query DSL在请求正文中指定搜索条件。您可以在请求URI中指定要搜索的索引的名称。</p>
<p>例如，以下请求将检索<code>bank</code>索引中按帐号排序的所有文档：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;bank&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123; &quot;account_number&quot;: &quot;asc&quot; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下，响应的<code>hit</code>部分包括符合搜索条件的前10个文档：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;took&quot;</span> : <span class="number">63</span>,</span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : <span class="number">5</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span> : <span class="number">5</span>,</span><br><span class="line">    <span class="attr">&quot;skipped&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;hits&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;value&quot;</span>: <span class="number">1000</span>,</span><br><span class="line">        <span class="attr">&quot;relation&quot;</span>: <span class="string">&quot;eq&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;max_score&quot;</span> : <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">&quot;hits&quot;</span> : [ &#123;</span><br><span class="line">      <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;bank&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;0&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;sort&quot;</span>: [<span class="number">0</span>],</span><br><span class="line">      <span class="attr">&quot;_score&quot;</span> : <span class="literal">null</span>,</span><br><span class="line">      <span class="attr">&quot;_source&quot;</span> : &#123;<span class="attr">&quot;account_number&quot;</span>:<span class="number">0</span>,<span class="attr">&quot;balance&quot;</span>:<span class="number">16623</span>,<span class="attr">&quot;firstname&quot;</span>:<span class="string">&quot;Bradshaw&quot;</span>,<span class="attr">&quot;lastname&quot;</span>:<span class="string">&quot;Mckenzie&quot;</span>,<span class="attr">&quot;age&quot;</span>:<span class="number">29</span>,<span class="attr">&quot;gender&quot;</span>:<span class="string">&quot;F&quot;</span>,<span class="attr">&quot;address&quot;</span>:<span class="string">&quot;244 Columbus Place&quot;</span>,<span class="attr">&quot;employer&quot;</span>:<span class="string">&quot;Euron&quot;</span>,<span class="attr">&quot;email&quot;</span>:<span class="string">&quot;bradshawmckenzie@euron.com&quot;</span>,<span class="attr">&quot;city&quot;</span>:<span class="string">&quot;Hobucken&quot;</span>,<span class="attr">&quot;state&quot;</span>:<span class="string">&quot;CO&quot;</span>&#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;bank&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;sort&quot;</span>: [<span class="number">1</span>],</span><br><span class="line">      <span class="attr">&quot;_score&quot;</span> : <span class="literal">null</span>,</span><br><span class="line">      <span class="attr">&quot;_source&quot;</span> : &#123;<span class="attr">&quot;account_number&quot;</span>:<span class="number">1</span>,<span class="attr">&quot;balance&quot;</span>:<span class="number">39225</span>,<span class="attr">&quot;firstname&quot;</span>:<span class="string">&quot;Amber&quot;</span>,<span class="attr">&quot;lastname&quot;</span>:<span class="string">&quot;Duke&quot;</span>,<span class="attr">&quot;age&quot;</span>:<span class="number">32</span>,<span class="attr">&quot;gender&quot;</span>:<span class="string">&quot;M&quot;</span>,<span class="attr">&quot;address&quot;</span>:<span class="string">&quot;880 Holmes Lane&quot;</span>,<span class="attr">&quot;employer&quot;</span>:<span class="string">&quot;Pyrami&quot;</span>,<span class="attr">&quot;email&quot;</span>:<span class="string">&quot;amberduke@pyrami.com&quot;</span>,<span class="attr">&quot;city&quot;</span>:<span class="string">&quot;Brogan&quot;</span>,<span class="attr">&quot;state&quot;</span>:<span class="string">&quot;IL&quot;</span>&#125;</span><br><span class="line">    &#125;, ...</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该响应还提供有关搜索请求的以下信息：</p>
<ul>
<li><code>took</code> – Elasticsearch运行查询所需的时间（以毫秒为单位）</li>
<li><code>timed_out</code> – 搜索请求是否超时</li>
<li><code>_shards</code> – 搜索了多少个分片以及成功，失败或跳过了多少个分片。or were skipped.</li>
<li><code>max_score</code> – 找到最相关文件的分数</li>
<li><code>hits.total.value</code> - 找到多少个匹配的文档</li>
<li><code>hits.sort</code> - 文档的排序位置（不按相关性得分排序时）</li>
<li><code>hits._score</code> - 文档的相关性得分（使用<code>match_all</code>时不适用）</li>
</ul>
<p>每个搜索请求都是独立的：Elasticsearch在请求中不维护任何状态信息。要翻阅搜索结果，请在请求中指定from和size参数。</p>
<p>例如，以下请求的匹配数为10到19：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;bank&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123; &quot;account_number&quot;: &quot;asc&quot; &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;from&quot;: 10,</span><br><span class="line">  &quot;size&quot;: 10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然您已经了解了如何提交基本的搜索请求，则可以开始构建比<code>match_all</code>有趣的查询。</p>
<p>要在字段中搜索特定字词，可以使用<code>match</code>查询。例如，以下请求搜索<code>address</code>字段以查找其地址包含<code>mill</code>或<code>land</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;bank&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;address&quot;: &quot;mill lane&quot; &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要构造更复杂的查询，可以使用<code>bool</code>查询来组合多个查询条件。您可以根据需要（must match），期望（shhould match）或不期望（must not match）指定条件。</p>
<p>例如，以下请求在<code>bank</code>索引中搜索属于40岁客户的帐户，但不包括居住在Idaho（ID）的任何人：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;bank&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;age&quot;: &quot;40&quot; &#125; &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;must_not&quot;: [</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;state&quot;: &quot;ID&quot; &#125; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>布尔查询中的每个must，should和must_not元素都称为查询子句。文档满足每个必须或应条款中的标准的程度会提高文档的相关性得分。分数越高，文档就越符合您的搜索条件。默认情况下，Elasticsearch返回按这些相关性分数排名的文档。</p>
<p>must_not子句中的条件被视为过滤器。它影响文件是否包含在结果中，但不会影响文件的评分方式。您还可以根据结构化数据显式指定任意过滤器以包括或排除文档。</p>
<p>例如，以下请求使用范围过滤器将结果限制为余额在20,000美元到30,000美元（含）之间的帐户。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;bank&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;,</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;range&quot;: &#123;</span><br><span class="line">          &quot;balance&quot;: &#123;</span><br><span class="line">            &quot;gte&quot;: 20000,</span><br><span class="line">            &quot;lte&quot;: 30000</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Analyze-results-with-aggregations"><a href="#Analyze-results-with-aggregations" class="headerlink" title="Analyze results with aggregations"></a><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/getting-started-aggregations.html">Analyze results with aggregations</a></h2><p>Elasticsearch聚合使您能够获取有关搜索结果的元信息，并回答诸如“德克萨斯州有多少个帐户持有人？”或“田纳西州的平均帐户余额是多少？”之类的问题。您可以在一个请求中搜索文档，过滤命中并使用汇总分析结果。</p>
<p>例如，以下请求使用<code>terms</code>汇总将<code>bank</code>索引中的所有帐户按状态分组，并按降序返回帐户数量最多的十个州：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;bank&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;: 0,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;group_by_state&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;state.keyword&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>响应中的<code>buckets</code>是<code>state</code>字段的值。<code>doc_count</code>显示每个状态下的帐户数。例如，您可以看到<code>ID（爱达荷州）</code>中有27个帐户。因为请求集<code>size=0</code>，所以响应仅包含聚合结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;took&quot;: 29,</span><br><span class="line">  &quot;timed_out&quot;: false,</span><br><span class="line">  &quot;_shards&quot;: &#123;</span><br><span class="line">    &quot;total&quot;: 5,</span><br><span class="line">    &quot;successful&quot;: 5,</span><br><span class="line">    &quot;skipped&quot; : 0,</span><br><span class="line">    &quot;failed&quot;: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;hits&quot; : &#123;</span><br><span class="line">     &quot;total&quot; : &#123;</span><br><span class="line">        &quot;value&quot;: 1000,</span><br><span class="line">        &quot;relation&quot;: &quot;eq&quot;</span><br><span class="line">     &#125;,</span><br><span class="line">    &quot;max_score&quot; : null,</span><br><span class="line">    &quot;hits&quot; : [ ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;aggregations&quot; : &#123;</span><br><span class="line">    &quot;group_by_state&quot; : &#123;</span><br><span class="line">      &quot;doc_count_error_upper_bound&quot;: 20,</span><br><span class="line">      &quot;sum_other_doc_count&quot;: 770,</span><br><span class="line">      &quot;buckets&quot; : [ &#123;</span><br><span class="line">        &quot;key&quot; : &quot;ID&quot;,</span><br><span class="line">        &quot;doc_count&quot; : 27</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        &quot;key&quot; : &quot;TX&quot;,</span><br><span class="line">        &quot;doc_count&quot; : 27</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        &quot;key&quot; : &quot;AL&quot;,</span><br><span class="line">        &quot;doc_count&quot; : 25</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        &quot;key&quot; : &quot;MD&quot;,</span><br><span class="line">        &quot;doc_count&quot; : 25</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        &quot;key&quot; : &quot;TN&quot;,</span><br><span class="line">        &quot;doc_count&quot; : 23</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        &quot;key&quot; : &quot;MA&quot;,</span><br><span class="line">        &quot;doc_count&quot; : 21</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        &quot;key&quot; : &quot;NC&quot;,</span><br><span class="line">        &quot;doc_count&quot; : 21</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        &quot;key&quot; : &quot;ND&quot;,</span><br><span class="line">        &quot;doc_count&quot; : 21</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        &quot;key&quot; : &quot;ME&quot;,</span><br><span class="line">        &quot;doc_count&quot; : 20</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        &quot;key&quot; : &quot;MO&quot;,</span><br><span class="line">        &quot;doc_count&quot; : 20</span><br><span class="line">      &#125; ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以组合聚合以构建更复杂的数据汇总。例如，以下请求在前一个<code>group_by_state</code>聚合内嵌套avg聚合，以计算每个状态的平均帐户余额。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;bank&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;: 0,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;group_by_state&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;state.keyword&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;aggs&quot;: &#123;</span><br><span class="line">        &quot;average_balance&quot;: &#123;</span><br><span class="line">          &quot;avg&quot;: &#123;</span><br><span class="line">            &quot;field&quot;: &quot;balance&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了这些基本的存储桶和指标聚合外，Elasticsearch还提供了专门的聚合，用于在多个字段上操作并分析特定类型的数据，例如日期，IP地址和地理数据。您还可以将单个聚合的结果馈送到管道聚合中，以进行进一步分析。</p>
<p>聚合提供的核心分析功能可启用高级功能，例如使用机器学习来检测异常。</p>
<h1 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h1><p>映射是定义文档及其包含的字段的存储和索引方式的过程。例如，使用映射定义：</p>
<ul>
<li>哪些字符串字段应视为全文字段。</li>
<li>哪些字段包含数字，日期或地理位置。</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/mapping-date-format.html">format</a> 日期值的格式。</li>
<li>自定义规则来控制动态添加字段的映射。 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/dynamic-mapping.html">dynamically added fields</a>.</li>
</ul>
<h2 id="Field-datatypes"><a href="#Field-datatypes" class="headerlink" title="Field datatypes"></a>Field datatypes</h2><p>每个字段的数据类型可以是：</p>
<ul>
<li>a simple type like <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/text.html"><code>text</code></a>, <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/keyword.html"><code>keyword</code></a>, <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/date.html"><code>date</code></a>, <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/number.html"><code>long</code></a>, <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/number.html"><code>double</code></a>, <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/boolean.html"><code>boolean</code></a> or <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/ip.html"><code>ip</code></a>.</li>
<li>支持JSON的层次结构性质的类型 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/object.html"><code>object</code></a> or <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/nested.html"><code>nested</code></a>.</li>
<li>专业型 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/geo-point.html"><code>geo_point</code></a>, <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/geo-shape.html"><code>geo_shape</code></a>, or <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/search-suggesters.html#completion-suggester"><code>completion</code></a>.</li>
</ul>
<p>为不同的目的以不同的方式对同一字段建立索引通常很有用。例如，可以将<code>string</code>字段索引为全文搜索的<code>text</code>字段，以及作为排序或聚合的<code>keyword</code>字段。另外，您可以使用标准分析器，英语分析器和法语分析器为字符串字段建立索引。</p>
<p>这是多字段的目的。大多数数据类型通过<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/multi-fields.html"><code>fields</code></a>参数支持多字段。</p>
<h2 id="Dynamic-mapping（动态映射）"><a href="#Dynamic-mapping（动态映射）" class="headerlink" title="Dynamic mapping（动态映射）"></a>Dynamic mapping（动态映射）</h2><p>字段和映射类型在使用之前不需要定义。通过动态映射，仅通过索引文档即可自动添加新的字段名称。新字段既可以添加到顶级映射类型，也可以添加到内部对象和嵌套字段。<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/object.html"><code>object</code></a> and <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/nested.html"><code>nested</code></a> </p>
<p>可以将动态映射规则配置为自定义用于新字段的映射。 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/dynamic-mapping.html">dynamic mapping</a></p>
<h2 id="使用显式映射创建索引"><a href="#使用显式映射创建索引" class="headerlink" title="使用显式映射创建索引"></a>使用显式映射创建索引</h2><p>您可以使用create index API创建带有显式映射的新索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;my-index</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;age&quot;:    &#123; &quot;type&quot;: &quot;integer&quot; &#125;,  </span><br><span class="line">      &quot;email&quot;:  &#123; &quot;type&quot;: &quot;keyword&quot;  &#125;, </span><br><span class="line">      &quot;name&quot;:   &#123; &quot;type&quot;: &quot;text&quot;  &#125;     </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Add-a-field-to-an-existing-mapping"><a href="#Add-a-field-to-an-existing-mapping" class="headerlink" title="Add a field to an existing mapping"></a>Add a field to an existing mapping</h2><p>将字段添加到现有映射 您可以使用放置映射API将一个或多个新字段添加到现有索引。</p>
<p>下面的示例添加employee-id，这是一个关键字字段，其索引映射参数值为false。这意味着已存储employee-id字段的值，但未编制索引或可用于搜索。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;my-index&#x2F;_mapping</span><br><span class="line">&#123;</span><br><span class="line">  &quot;properties&quot;: &#123;</span><br><span class="line">    &quot;employee-id&quot;: &#123;</span><br><span class="line">      &quot;type&quot;: &quot;keyword&quot;,</span><br><span class="line">      &quot;index&quot;: false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="更新字段的映射"><a href="#更新字段的映射" class="headerlink" title="更新字段的映射"></a>更新字段的映射</h3><p>您不能更改现有字段的映射，但以下情况除外：</p>
<ul>
<li>You can add new <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/properties.html">properties</a> to an <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/object.html"><code>object</code></a> field.</li>
<li>您可以使用字段映射参数来启用多字段。 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/multi-fields.html"><code>field</code></a> </li>
<li>您可以更改ignore_above映射参数的值。 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/ignore-above.html"><code>ignore_above</code></a> </li>
</ul>
<p>更改现有字段的映射可能会使已经建立索引的数据无效。如果需要更改字段的映射，请使用正确的映射创建一个新索引，然后将数据重新索引 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/docs-reindex.html">reindex</a> 到该索引中。如果只想重命名字段，请考虑添加别名 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/alias.html"><code>alias</code></a> 字段。</p>
<h2 id="查看索引的映射"><a href="#查看索引的映射" class="headerlink" title="查看索引的映射"></a>查看索引的映射</h2><p>您可以使用get mapping API查看现有索引的映射。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;my-index&#x2F;_mapping</span><br></pre></td></tr></table></figure>


<h1 id="Query-DSL"><a href="#Query-DSL" class="headerlink" title="Query DSL"></a>Query DSL</h1><p>Elasticsearch提供了基于JSON的完整查询DSL（特定于域的语言）来定义查询。将查询DSL视为查询的AST（抽象语法树），它由两种子句组成：</p>
<ul>
<li><p><strong>Leaf query clauses</strong></p>
<p>叶子查询子句在特定字段中查找特定值，例如match，term或range查询。这些查询可以自己使用。</p>
</li>
<li><p><strong>Compound query clauses</strong></p>
<p>复合查询子句包装其他叶查询或复合查询，并用于以逻辑方式组合多个查询（例如bool或dis_max查询），或更改其行为（例如constant_score查询）。</p>
</li>
</ul>
<p>查询子句的行为会有所不同，具体取决于它们是在查询上下文中还是在过滤器上下文中使用。 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/query-filter-context.html">query context or filter context</a>.</p>
<h2 id="查询和过滤上下文"><a href="#查询和过滤上下文" class="headerlink" title="查询和过滤上下文"></a>查询和过滤上下文</h2><h3 id="Relevance-scores"><a href="#Relevance-scores" class="headerlink" title="Relevance scores"></a>Relevance scores</h3><p>默认情况下，Elasticsearch按<strong>相关性得分</strong>对匹配的搜索结果进行排序，该得分衡量每个文档与查询的匹配程度。</p>
<p>相关性分数是一个正浮点数，在<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/search-request-body.html">search</a>API的_score元字段中返回。 _score越高，文档越相关。虽然每种查询类型可以不同地计算相关性分数，但是分数计算还取决于查询子句是在查询上下文中还是在过滤器上下文中运行。</p>
<h3 id="Query-context-查询上下文"><a href="#Query-context-查询上下文" class="headerlink" title="Query context 查询上下文"></a>Query context 查询上下文</h3><p>在查询上下文中，查询子句回答“此文档与该查询子句的匹配程度如何”的问题。除了确定文档是否匹配外，查询子句还计算<code>_score</code>元字段中的相关性得分。</p>
<p>每当将查询子句传递到查询参数（例如搜索API中的查询参数）时，查询上下文即生效。</p>
<h3 id="Filter-context-过滤上下文"><a href="#Filter-context-过滤上下文" class="headerlink" title="Filter context 过滤上下文"></a>Filter context 过滤上下文</h3><p>在过滤器上下文中，查询子句回答问题“此文档是否与此查询子句匹配？”答案是简单的“是”或“否”，即不计算分数。过滤器上下文主要用于过滤结构化数据，例如</p>
<ul>
<li><em>Does this <code>timestamp</code> fall into the range 2015 to 2016?</em></li>
<li><em>Is the <code>status</code> field set to <code>&quot;published&quot;</code></em>?</li>
</ul>
<p>常用过滤器将由Elasticsearch自动缓存，以提高性能。</p>
<p>每当将查询子句传递到过滤器参数（例如bool查询中的filter或must_not参数，constant_score查询中的filter参数或过滤器聚合）时，过滤器上下文即生效。</p>
<h3 id="Example-of-query-and-filter-contexts"><a href="#Example-of-query-and-filter-contexts" class="headerlink" title="Example of query and filter contexts"></a>Example of query and filter contexts</h3><p>以下是在searchAPI的查询和过滤器上下文中使用的查询子句的示例。此查询将匹配满足以下所有条件的文档：</p>
<ul>
<li>The <code>title</code> field contains the word <code>search</code>.</li>
<li>The <code>content</code> field contains the word <code>elasticsearch</code>.</li>
<li>The <code>status</code> field contains the exact word <code>published</code>.</li>
<li>The <code>publish_date</code> field contains a date from 1 Jan 2015 onwards.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123; </span><br><span class="line">    &quot;bool&quot;: &#123; </span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;title&quot;:   &quot;Search&quot;        &#125;&#125;,</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;content&quot;: &quot;Elasticsearch&quot; &#125;&#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;filter&quot;: [ </span><br><span class="line">        &#123; &quot;term&quot;:  &#123; &quot;status&quot;: &quot;published&quot; &#125;&#125;,</span><br><span class="line">        &#123; &quot;range&quot;: &#123; &quot;publish_date&quot;: &#123; &quot;gte&quot;: &quot;2015-01-01&quot; &#125;&#125;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>The <code>query</code> parameter indicates query context.</li>
<li><code>bool</code>和两个<code>match</code>子句用于查询上下文，这意味着它们用于对每个文档的匹配程度进行评分。</li>
<li><code>filter</code>参数指示过滤器上下文。其<code>term</code>和<code>range</code>子句用于过滤器上下文。它们将过滤出不匹配的文档，但不会影响匹配文档的分数。</li>
</ul>
<p>在查询上下文中为查询计算的分数表示为单精度浮点数；它们只有24位才能表示有效的精度。超过有效位数的分数计算将被转换为浮点数而失去精度。</p>
<p>在查询上下文中使用查询子句来确定会影响匹配文档得分的条件（即文档匹配程度），并在过滤器上下文中使用所有其他查询子句。</p>
<h2 id="Compound-queries-复合查询"><a href="#Compound-queries-复合查询" class="headerlink" title="Compound queries 复合查询"></a>Compound queries 复合查询</h2><p>复合查询包装其他复合查询或叶查询，以组合其结果和分数，更改其行为或从查询切换到过滤器上下文。</p>
<p>该组中的查询是：</p>
<ul>
<li><p><strong><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/query-dsl-bool-query.html"><code>bool</code> query</a></strong></p>
<p>默认查询，用于组合多个叶子或复合查询子句（must，should，must_not或filter子句）。must和should子句的分数组合在一起-匹配的子句越多越好-而must_not和filter子句在过滤器上下文中执行。</p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/query-dsl-boosting-query.html"><code>boosting</code> query</a></strong></p>
<p>返回与肯定查询匹配的文档，但减少与否定查询匹配的文档的分数。</p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/query-dsl-constant-score-query.html"><code>constant_score</code> query</a></strong></p>
<p>一个查询，它包装另一个查询，但是在过滤器上下文中执行它。所有匹配的文档都使用相同的“常量”<code> _score</code>。</p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/query-dsl-dis-max-query.html"><code>dis_max</code> query</a></strong></p>
<p>一个查询，它接受多个查询，并返回与任何查询子句匹配的任何文档。当布尔查询合并所有匹配查询的分数时，dis_max查询使用单个最佳匹配查询子句的分数。</p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/query-dsl-function-score-query.html"><code>function_score</code> query</a></strong></p>
<p>使用functions修改主查询返回的分数，以考虑诸如受欢迎程度，新近度，距离或使用脚本实现的自定义算法等因素。</p>
</li>
</ul>
<h3 id="Boolean-query"><a href="#Boolean-query" class="headerlink" title="Boolean query"></a>Boolean query</h3><p>与文档匹配的查询，这些文档与其他查询的布尔组合匹配。布尔查询映射到Lucene BooleanQuery。它是使用一个或多个布尔子句构建的，每个子句都具有类型的出现。发生类型为：</p>
<table>
<thead>
<tr>
<th>Occur</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>must</code></td>
<td>子句（查询）必须出现在匹配的文档中，并将有助于得分。</td>
</tr>
<tr>
<td><code>filter</code></td>
<td>子句（查询）必须出现在匹配的文档中。但是与查询分数不同的是，忽略该分数。 Filter子句在过滤器上下文中执行，这意味着计分被忽略，并且子句被视为用于缓存。</td>
</tr>
<tr>
<td><code>should</code></td>
<td>子句（查询）应出现在匹配的文档中。</td>
</tr>
<tr>
<td><code>must_not</code></td>
<td>子句（查询）不得出现在匹配的文档中。子句在过滤器上下文中执行，这意味着计分被忽略，并且子句被视为用于缓存。由于计分被忽略，因此所有文档的分数均返回0。</td>
</tr>
</tbody></table>
<p>The <code>bool</code> query takes a <em>more-matches-is-better</em> approach, so the score from each matching <code>must</code> or <code>should</code> clause will be added together to provide the final <code>_score</code> for each document.</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">POST _search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;bool&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;must&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;term&quot;</span> : &#123; <span class="attr">&quot;user&quot;</span> : <span class="string">&quot;kimchy&quot;</span> &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;filter&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;term&quot;</span> : &#123; <span class="attr">&quot;tag&quot;</span> : <span class="string">&quot;tech&quot;</span> &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;must_not&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;range&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;age&quot;</span> : &#123; <span class="attr">&quot;gte&quot;</span> : <span class="number">10</span>, <span class="attr">&quot;lte&quot;</span> : <span class="number">20</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;should&quot;</span> : [</span><br><span class="line">        &#123; <span class="attr">&quot;term&quot;</span> : &#123; <span class="attr">&quot;tag&quot;</span> : <span class="string">&quot;wow&quot;</span> &#125; &#125;,</span><br><span class="line">        &#123; <span class="attr">&quot;term&quot;</span> : &#123; <span class="attr">&quot;tag&quot;</span> : <span class="string">&quot;elasticsearch&quot;</span> &#125; &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;minimum_should_match&quot;</span> : <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;boost&quot;</span> : <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在filter元素下指定的查询对得分没有影响-得分将返回0。得分仅受指定查询的影响。</p>
<h3 id="Boosting-query"><a href="#Boosting-query" class="headerlink" title="Boosting query"></a>Boosting query</h3><p>返回匹配肯定查询的文档，同时降低也匹配否定查询的文档的相关性得分。</p>
<p>您可以使用<code>boosting</code>查询来降级某些文档，而不必将它们从搜索结果中排除。</p>
<p><strong><code>positive</code></strong></p>
<p>（必需的查询对象）要运行的查询。返回的所有文档都必须与此查询匹配。</p>
<p><strong><code>negative</code></strong></p>
<p>（必需的查询对象）查询用于降低匹配文档的相关性得分。</p>
<p>如果返回的文档与肯定查询和该查询匹配，则增强查询将计算该文档的最终相关性得分，如下所示：</p>
<ol>
<li>从肯定查询中获取原始的相关性分数。</li>
<li>将分数乘以negative_boost值。</li>
</ol>
<p><strong><code>negative_boost</code></strong></p>
<p>（必需，浮点数）0到1.0之间的浮点数，用于降低与否定查询匹配的文档的相关性得分。</p>
<h4 id="Example-request"><a href="#Example-request" class="headerlink" title="Example request"></a>Example request</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;bank&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;boosting&quot;: &#123;</span><br><span class="line">      &quot;positive&quot;: &#123;</span><br><span class="line">        &quot;match&quot;: &#123;</span><br><span class="line">          &quot;state&quot;: &quot;ID&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;negative&quot;: &#123;</span><br><span class="line">        &quot;range&quot;: &#123;</span><br><span class="line">          &quot;balance&quot;: &#123;</span><br><span class="line">            &quot;gte&quot;: 20000,</span><br><span class="line">            &quot;lte&quot;: 30000</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;negative_boost&quot;: 0.5</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Constant-score-query"><a href="#Constant-score-query" class="headerlink" title="Constant score query"></a>Constant score query</h3><p>包装<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/query-dsl-bool-query.html">过滤查询，</a>并返回每个<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/query-filter-context.html#relevance-scores">相关</a>文档的<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/query-filter-context.html#relevance-scores">相关性得分</a>等于<code>boost</code> 参数值。</p>
<p><strong><code>filter</code></strong></p>
<p>（必需的查询对象）<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/query-dsl-bool-query.html">过滤</a>要运行的<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/query-dsl-bool-query.html">查询</a>。返回的所有文档都必须与此查询匹配。</p>
<p>过滤查询不计算<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/query-filter-context.html#relevance-scores">相关性分数</a>。为了提高性能，Elasticsearch自动缓存经常使用的过滤器查询。</p>
<p><strong><code>boost</code></strong></p>
<p>（可选，float）浮点数用作与查询匹配的每个文档 的恒定 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/query-filter-context.html#relevance-scores">相关性得分</a><code>filter</code>。默认为<code>1.0</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;bank&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;constant_score&quot;: &#123;</span><br><span class="line">      &quot;filter&quot;: &#123;&quot;range&quot;: &#123;</span><br><span class="line">        &quot;balance&quot;: &#123;</span><br><span class="line">          &quot;gte&quot;: 20000,</span><br><span class="line">          &quot;lte&quot;: 30000</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;&#125;,</span><br><span class="line">      &quot;boost&quot;: 0.1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Full-text-queries-全文检索"><a href="#Full-text-queries-全文检索" class="headerlink" title="Full text queries 全文检索"></a>Full text queries 全文检索</h2><p>全文查询使您可以搜索已<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/analysis.html">分析的文本字段，</a>例如电子邮件的正文。使用在索引期间应用于字段的同一分析器来处理查询字符串。</p>
<p>该组中的查询是：</p>
<ul>
<li><p><strong><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/query-dsl-intervals-query.html"><code>intervals</code> query</a></strong></p>
<p>全文查询，可以对匹配项的顺序和接近度进行细粒度控制。</p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/query-dsl-match-query.html"><code>match</code> query</a></strong></p>
<p>用于执行全文查询的标准查询，包括模糊匹配和短语或接近查询。</p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/query-dsl-match-bool-prefix-query.html"><code>match_bool_prefix</code> query</a></strong></p>
<p>创建一个<code>bool</code>与每个词条匹配的<code>term</code>查询作为查询，但最后一个词条作为<code>prefix</code>查询匹配</p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/query-dsl-match-query-phrase.html"><code>match_phrase</code>query</a></strong></p>
<p>与<code>match</code>查询类似，但用于匹配确切的短语或单词接近匹配。</p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/query-dsl-match-query-phrase-prefix.html"><code>match_phrase_prefix</code> query</a></strong></p>
<p>与<code>match_phrase</code>查询类似，但是对最后一个单词进行通配符搜索。</p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/query-dsl-multi-match-query.html"><code>multi_match</code> query</a></strong></p>
<p><code>match</code>查询的多字段版本。</p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/query-dsl-common-terms-query.html"><code>common</code> terms query</a></strong></p>
<p>一个更专业的查询，它对不常见的单词给予更多的偏爱。</p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/query-dsl-query-string-query.html"><code>query_string</code>query</a></strong></p>
<p>支持紧凑的Lucene <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/query-dsl-query-string-query.html#query-string-syntax">查询字符串语法</a>，允许您在单个查询字符串中指定AND | OR | NOT条件和多字段搜索。仅限于专业用户。</p>
</li>
<li><p><strong><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/query-dsl-simple-query-string-query.html"><code>simple_query_string</code>query</a></strong></p>
<p><code>query_string</code>适用于直接向用户公开的语法的更简单，更可靠的版本。</p>
</li>
</ul>
<h3 id="Intervals-query"><a href="#Intervals-query" class="headerlink" title="Intervals query"></a>Intervals query</h3><p>根据匹配项的顺序和接近程度返回文档。</p>
<p>间隔查询使用匹配规则，该规则由一小组定义构成。然后将这些规则应用于来自指定字段的术语。</p>
<p>这些定义产生的最小间隔序列跨越了文本主体中的各个术语。这些间隔可以由父源进一步组合和过滤。</p>
<h3 id="Match-query"><a href="#Match-query" class="headerlink" title="Match query"></a>Match query</h3><p>返回与提供的文本，数字，日期或布尔值匹配的文档。匹配之前分析提供的文本。</p>
<p>匹配查询是用于执行全文搜索的标准查询，其中包括模糊匹配的选项。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;match&quot; : &#123;</span><br><span class="line">            &quot;message&quot; : &#123;</span><br><span class="line">                &quot;query&quot; : &quot;this is a test&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="REST-APIs"><a href="#REST-APIs" class="headerlink" title="REST APIs"></a>REST APIs</h1><h2 id="Index-APIs"><a href="#Index-APIs" class="headerlink" title="Index APIs"></a>Index APIs</h2><h3 id="Create-Index"><a href="#Create-Index" class="headerlink" title="Create Index"></a>Create Index</h3><p>创建一个新索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;twitter</span><br></pre></td></tr></table></figure>
<h4 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;&lt;index&gt;</span><br></pre></td></tr></table></figure>
<h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><p>您可以使用create index API将新索引添加到Elasticsearch集群。创建索引时，可以指定以下内容：</p>
<ul>
<li>Settings  索引设置</li>
<li>Mappings 索引中字段的映射</li>
<li>Index aliases 索引别名</li>
</ul>
<h4 id="Path-parameters"><a href="#Path-parameters" class="headerlink" title="Path parameters"></a>Path parameters</h4><p>**<code>&lt;index&gt;</code>**（可选，字符串）您要创建的索引的名称。</p>
<p>索引名称必须满足以下条件：</p>
<ul>
<li>Lowercase only</li>
<li>Cannot include <code>\</code>, <code>/</code>, <code>*</code>, <code>?</code>, <code>&quot;</code>, <code>&lt;</code>, <code>&gt;</code>, <code>|</code>, <code> </code> (space character), <code>,</code>, <code>#</code></li>
<li>Indices prior to 7.0 could contain a colon (<code>:</code>), but that’s been deprecated and won’t be supported in 7.0+</li>
<li>Cannot start with <code>-</code>, <code>_</code>, <code>+</code></li>
<li>Cannot be <code>.</code> or <code>..</code></li>
<li>Cannot be longer than 255 bytes (note it is bytes, so multi-byte characters will count towards the 255 limit faster)</li>
</ul>
<h4 id="Query-parameters"><a href="#Query-parameters" class="headerlink" title="Query parameters"></a>Query parameters</h4><ul>
<li><p><strong><code>include_type_name</code></strong></p>
<p>[7.0.0] Deprecated in 7.0.0. Mapping types have been deprecated. See <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/removal-of-types.html"><em>Removal of mapping types</em></a>.(Optional, boolean) If <code>true</code>, a mapping type is expected in the body of mappings. Defaults to <code>false</code>.</p>
</li>
<li><p><strong><code>wait_for_active_shards</code></strong></p>
<p>（可选，字符串）在继续操作之前必须处于活动状态的分片副本数。设置为全部或任何正整数，直到索引中的分片总数（number_of_replicas + 1）。默认值：1，主分片。</p>
</li>
<li><p><strong><code>timeout</code></strong></p>
<p>（可选，时间单位）指定等待响应的时间。如果在超时到期之前未收到任何响应，则请求将失败并返回错误。默认为30秒。</p>
</li>
<li><p><strong><code>master_timeout</code></strong></p>
<p>（可选，时间单位）指定等待连接到主节点的时间段。如果在超时到期之前未收到任何响应，则请求将失败并返回错误。默认为30秒。</p>
</li>
</ul>
<h4 id="Request-body"><a href="#Request-body" class="headerlink" title="Request body"></a>Request body</h4><ul>
<li><p><strong><code>aliases</code></strong></p>
<p>(Optional, <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/indices-aliases.html">alias object</a>) Index aliases which include the index. See <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/indices-aliases.html">Update index alias</a>.</p>
</li>
<li><p><strong><code>mappings</code></strong></p>
<p>(Optional, <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/mapping.html">mapping object</a>) Mapping for fields in the index. If specified, this mapping can include:</p>
<ul>
<li><p>Field names</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/mapping-types.html">Field datatypes</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/mapping-params.html">Mapping parameters</a></p>
<p>See <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/mapping.html">Mapping</a>.</p>
</li>
</ul>
</li>
<li><p><strong><code>settings</code></strong></p>
<p>(Optional, <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/index-modules.html#index-modules-settings">index setting object</a>) Configuration options for the index. See <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/index-modules.html#index-modules-settings">Index Settings</a>.</p>
</li>
</ul>
<h4 id="Examples例子"><a href="#Examples例子" class="headerlink" title="Examples例子"></a>Examples例子</h4><h5 id="Index-settings索引设置"><a href="#Index-settings索引设置" class="headerlink" title="Index settings索引设置"></a>Index settings索引设置</h5><p>创建的每个索引都可以具有与之关联的特定设置，这些设置在主体中定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;twitter</span><br><span class="line">&#123;</span><br><span class="line">    &quot;settings&quot; : &#123;</span><br><span class="line">        &quot;index&quot; : &#123;</span><br><span class="line">            &quot;number_of_shards&quot; : 3,  默认1</span><br><span class="line">            &quot;number_of_replicas&quot; : 2  默认1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT &#x2F;twitter</span><br><span class="line">&#123;</span><br><span class="line">    &quot;settings&quot; : &#123;</span><br><span class="line">        &quot;number_of_shards&quot; : 3,</span><br><span class="line">        &quot;number_of_replicas&quot; : 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Mapping-1"><a href="#Mapping-1" class="headerlink" title="Mapping"></a>Mapping</h5><p>创建索引API允许提供映射定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;test</span><br><span class="line">&#123;</span><br><span class="line">    &quot;settings&quot; : &#123;</span><br><span class="line">        &quot;number_of_shards&quot; : 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;mappings&quot; : &#123;</span><br><span class="line">        &quot;properties&quot; : &#123;</span><br><span class="line">            &quot;field1&quot; : &#123; &quot;type&quot; : &quot;text&quot; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Aliases"><a href="#Aliases" class="headerlink" title="Aliases"></a>Aliases</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;test</span><br><span class="line">&#123;</span><br><span class="line">    &quot;aliases&quot; : &#123;</span><br><span class="line">        &quot;alias_1&quot; : &#123;&#125;,</span><br><span class="line">        &quot;alias_2&quot; : &#123;</span><br><span class="line">            &quot;filter&quot; : &#123;</span><br><span class="line">                &quot;term&quot; : &#123;&quot;user&quot; : &quot;kimchy&quot; &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;routing&quot; : &quot;kimchy&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下，索引创建仅在每个分片的主副本已启动或请求超时时才向客户端返回响应。索引创建响应将指示发生了什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;acknowledged&quot;: true,</span><br><span class="line">    &quot;shards_acknowledged&quot;: true,</span><br><span class="line">    &quot;index&quot;: &quot;test&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>acknowledged</code> 指示索引是否在集群中成功创建, 而<code>shards_acknowledged</code> 指示在超时之前是否为索引中的每个分片启动了必要数量的分片副本。请注意，<code>acknowledged</code> 或<code>shards_acknowledged</code>仍然可能为假，但索引创建成功。 这些值仅表示操作是否在超时之前完成。如果accepted为false，那么在使用新创建的索引更新集群状态之前，我们会超时，但是可能很快就会创建它。 If <code>shards_acknowledged</code> is <code>false</code>, then we timed out before the requisite number of shards were started (by default just the primaries), even if the cluster state was successfully updated to reflect the newly created index (i.e. <code>acknowledged=true</code>).</p>
<p>我们可以通过索引设置index.write.wait_for_active_shards更改仅等待主分片启动的默认设置</p>
<h2 id="Search-APIs"><a href="#Search-APIs" class="headerlink" title="Search APIs"></a>Search APIs</h2><p>Most search APIs are <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/search-search.html#search-multi-index">multi-index</a>, with the exception of the <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/search-explain.html">Explain API</a> endpoints.</p>
<h3 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h3><p>返回与请求中定义的查询匹配的搜索命中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;twitter&#x2F;_search?q&#x3D;tag:wow</span><br></pre></td></tr></table></figure>
<h4 id="Request-1"><a href="#Request-1" class="headerlink" title="Request"></a>Request</h4><p><code>GET /&lt;index&gt;/_search</code></p>
<p><code>POST /&lt;index&gt;/_search</code></p>
<p><code>GET /_search</code></p>
<p><code>POST /_search</code></p>
<h4 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h4><p>允许您执行搜索查询并获取与查询匹配的搜索命中。可以使用简单查询字符串作为参数来提供查询，也可以使用请求正文来提供查询。 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/search-uri-request.html">query string as a parameter</a>, or using a <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/search-request-body.html">request body</a>.</p>
<p>为确保快速响应，如果一个或多个分片失败，搜索API将以部分结果响应。有关更多信息，请参见分片故障。</p>
<h4 id="Path-parameters-1"><a href="#Path-parameters-1" class="headerlink" title="Path parameters"></a>Path parameters</h4><p>**<code>&lt;index&gt;</code>**（可选，字符串）索引名称的逗号分隔列表或通配符表达式，用于限制请求。</p>
<h4 id="Query-parameters-1"><a href="#Query-parameters-1" class="headerlink" title="Query parameters"></a>Query parameters</h4><p><strong><code>allow_no_indices</code></strong></p>
<p>（可选，布尔值）如果为true，则如果通配符表达式或_all值仅检索丢失或闭合的索引，则请求不会返回错误。</p>
<p>此参数还适用于指向别名缺失或封闭索引的索引别名。</p>
<p><strong><code>allow_partial_search_results</code></strong></p>
<p>（可选，布尔值）指示如果部分搜索失败或超时，是否应返回错误。默认为true。</p>
<h4 id="Request-body-1"><a href="#Request-body-1" class="headerlink" title="Request body"></a>Request body</h4><p><strong><code>query</code></strong></p>
<p>(Optional, <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/query-dsl.html">query object</a>) Defines the search definition using the <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/query-dsl.html">Query DSL</a>.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">oneyoung</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/oneyoungg" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;oneyoungg" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">oneyoung</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
