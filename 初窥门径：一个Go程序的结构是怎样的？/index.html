<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"oneyoung.top","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="是时候撸起袖子开始写 Go 代码了！ 程序员这个历史并不算悠久的行当，却有着一个历史悠久的传统，那就是每种编程语言都将一个名为“hello, world”的示例作为这门语言学习的第一个例子，这个传统始于 20 世纪 70 年代那本大名鼎鼎的由布莱恩·科尼根（Brian W. Kernighan）与 C 语言之父丹尼斯·里奇（Dennis M. Ritchie）合著的《C 程序设计语言》。  从编写">
<meta property="og:type" content="article">
<meta property="og:title" content="初窥门径：一个Go程序的结构是怎样的？">
<meta property="og:url" content="https://oneyoung.top/%E5%88%9D%E7%AA%A5%E9%97%A8%E5%BE%84%EF%BC%9A%E4%B8%80%E4%B8%AAGo%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%93%E6%9E%84%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F/index.html">
<meta property="og:site_name" content="无涯">
<meta property="og:description" content="是时候撸起袖子开始写 Go 代码了！ 程序员这个历史并不算悠久的行当，却有着一个历史悠久的传统，那就是每种编程语言都将一个名为“hello, world”的示例作为这门语言学习的第一个例子，这个传统始于 20 世纪 70 年代那本大名鼎鼎的由布莱恩·科尼根（Brian W. Kernighan）与 C 语言之父丹尼斯·里奇（Dennis M. Ritchie）合著的《C 程序设计语言》。  从编写">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://oneyoung.top/%E5%88%9D%E7%AA%A5%E9%97%A8%E5%BE%84%EF%BC%9A%E4%B8%80%E4%B8%AAGo%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%93%E6%9E%84%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F/43173ef6d422682c70a5c09b6c9f728a.png">
<meta property="article:published_time" content="2022-06-18T03:46:16.000Z">
<meta property="article:modified_time" content="2022-06-18T04:18:01.251Z">
<meta property="article:author" content="oneyoung">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://oneyoung.top/%E5%88%9D%E7%AA%A5%E9%97%A8%E5%BE%84%EF%BC%9A%E4%B8%80%E4%B8%AAGo%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%93%E6%9E%84%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F/43173ef6d422682c70a5c09b6c9f728a.png">

<link rel="canonical" href="https://oneyoung.top/%E5%88%9D%E7%AA%A5%E9%97%A8%E5%BE%84%EF%BC%9A%E4%B8%80%E4%B8%AAGo%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%93%E6%9E%84%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>初窥门径：一个Go程序的结构是怎样的？ | 无涯</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">无涯</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">无所谓无 无所谓有</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/oneyoungg" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://oneyoung.top/%E5%88%9D%E7%AA%A5%E9%97%A8%E5%BE%84%EF%BC%9A%E4%B8%80%E4%B8%AAGo%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%93%E6%9E%84%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="oneyoung">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无涯">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          初窥门径：一个Go程序的结构是怎样的？
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-18 11:46:16 / 修改时间：12:18:01" itemprop="dateCreated datePublished" datetime="2022-06-18T11:46:16+08:00">2022-06-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>是时候撸起袖子开始写 Go 代码了！</p>
<p>程序员这个历史并不算悠久的行当，却有着一个历史悠久的传统，那就是每种编程语言都将一个名为“hello, world”的示例作为这门语言学习的第一个例子，这个传统始于 20 世纪 70 年代那本大名鼎鼎的由布莱恩·科尼根（Brian W. Kernighan）与 C 语言之父丹尼斯·里奇（Dennis M. Ritchie）合著的《C 程序设计语言》。</p>
<p><img src="/%E5%88%9D%E7%AA%A5%E9%97%A8%E5%BE%84%EF%BC%9A%E4%B8%80%E4%B8%AAGo%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%93%E6%9E%84%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F/43173ef6d422682c70a5c09b6c9f728a.png" alt="img"></p>
<p>从编写一个可以打印出“hello, world”的 Go 示例程序开始我们正式的 Go 编码之旅。我希望通过这个示例程序你能够对 Go 程序结构有一个直观且清晰的认识。</p>
<p>这篇文章对你开发 Go 程序时所使用的编辑器工具没有任何具体的要求。</p>
<p>如果你喜欢使用某个集成开发环境（Integrated Development Environment，IDE），那么就用你喜欢的 IDE 好了。如果你希望我给你推荐一些好用的 IDE，我建议你试试GoLand或Visual Studio Code（简称 VS Code）。GoLand 是知名 IDE 出品公司 JetBrains 针对 Go 语言推出的 IDE 产品，也是目前市面上最好用的 Go IDE；VS Code 则是微软开源的跨语言源码编辑器，通过集成语言插件（Go 开发者可以使用 Go 官方维护的vscode-go 插件），可以让它变成类 IDE 的工具。</p>
<p>如果你有黑客情怀，喜欢像黑客一样优雅高效地使用命令行，那么像 Vim、Emacs 这样的基于终端的编辑器同样可以用于编写 Go 源码。以 Vim 为例，结合vim-go、coc.nvim（代码补全）以及 Go 官方维护的gopls语言服务器，你在编写 Go 代码时同样可以体会到“飞一般”的感觉。但在我们这门课中，我们将尽量使用与编辑器或 IDE 无关的说明。</p>
<h2 id="创建“hello，world”示例程序"><a href="#创建“hello，world”示例程序" class="headerlink" title="创建“hello，world”示例程序"></a>创建“hello，world”示例程序</h2><p>在 Go 语言中编写一个可以打印出“hello，world”的示例程序，我们只需要简单两步，一是创建文件夹，二是开始编写和运行。首先，我们来创建一个文件夹存储编写的 Go 代码。</p>
<h2 id="创建“hello，world”文件夹"><a href="#创建“hello，world”文件夹" class="headerlink" title="创建“hello，world”文件夹"></a>创建“hello，world”文件夹</h2><p>通常来说，Go 不会限制我们存储代码的位置（Go 1.11 之前的版本另当别论）。但是针对我们这门课里的各种练习和项目，我还是建议你创建一个可以集合所有项目的根文件夹（比如：~/goprojects），然后将我们这门课中所有的项目都放在里面。</p>
<p>现在，你可以打开终端并输入相应命令，来创建我们用于储存“hello，world”示例的文件夹 helloworld 了。对于 Linux 系统、macOS 系统，以及 Windows 系统的 PowerShell 终端来说，用下面这个命令就可以建立 helloworld 文件夹了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/goprojects // 创建一个可以集合所有专栏项目的根文件夹</span><br><span class="line">cd ~/goprojects</span><br><span class="line">mkdir helloworld // 创建存储helloworld示例的文件夹</span><br><span class="line">cd helloworld</span><br></pre></td></tr></table></figure>
<p>建好文件夹后，我们就要开始编写我们第一个 Go 程序了。</p>
<h2 id="编写并运行第一个-Go-程序"><a href="#编写并运行第一个-Go-程序" class="headerlink" title="编写并运行第一个 Go 程序"></a>编写并运行第一个 Go 程序</h2><p>首先，我们需要创建一个名为 main.go 的源文件。</p>
<p>这里，我需要跟你啰嗦一下 Go 的命名规则。Go 源文件总是用全小写字母形式的短小单词命名，并且以.go 扩展名结尾。</p>
<p>如果要在源文件的名字中使用多个单词，我们通常直接是将多个单词连接起来作为源文件名，而不是使用其他分隔符，比如下划线。也就是说，我们通常使用 helloworld.go 作为文件名而不是 hello_world.go。</p>
<p>这是因为下划线这种分隔符，在 Go 源文件命名中有特殊作用，这个我们会在以后的讲解中详细说明。总的来说，我们尽量不要用两个以上的单词组合作为文件名，否则就很难分辨了。</p>
<p>现在，你可以打开刚刚创建的 main.go 文件，键入下面这些代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello, world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写完后，我们保存文件并回到终端窗口，然后在 Linux 或 macOS 系统中，你就可以通过输入下面这个命令来编译和运行这个文件了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go build main.go</span><br><span class="line">./main</span><br><span class="line">hello, world</span><br></pre></td></tr></table></figure>
<p>看到终端输出的“hello, world”字符串了。如果你没有看到这个输出结果，要么是 Go 安装过程的问题，要么是源文件编辑出现了问题，需要你再次认真地确认。如果一切顺利，那么恭喜你！你已经完成了第一个 Go 程序，并正式成为了 Go 开发者！欢迎来到 Go 语言的世界！</p>
<h2 id="“hello，world”示例程序的结构"><a href="#“hello，world”示例程序的结构" class="headerlink" title="“hello，world”示例程序的结构"></a>“hello，world”示例程序的结构</h2><p>现在，让我们回过头来仔细看看“hello，world”示例程序中到底发生了什么。第一个值得注意的部分是这个：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br></pre></td></tr></table></figure>
<p>这一行代码定义了 Go 中的一个包 package。包是 Go 语言的基本组成单元，通常使用单个的小写单词命名，一个 Go 程序本质上就是一组包的集合。所有 Go 代码都有自己隶属的包，在这里我们的“hello，world”示例的所有代码都在一个名为 main 的包中。main 包在 Go 中是一个特殊的包，<strong>整个 Go 程序中仅允许存在一个名为 main 的包。</strong></p>
<p>main 包中的主要代码是一个名为 main 的函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello, world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这里的 main 函数会比较特殊：当你运行一个可执行的 Go 程序的时候，所有的代码都会从这个入口函数开始运行。</strong>这段代码的第一行声明了一个名为 main 的、没有任何参数和返回值的函数。如果某天你需要给函数声明参数的话，那么就必须把它们放置在圆括号 () 中。</p>
<p>另外，那对花括号{}被用来标记函数体，Go 要求所有的函数体都要被花括号包裹起来。按照惯例，我们推荐把左花括号与函数声明置于同一行并以空格分隔。Go 语言内置了一套 Go 社区约定俗称的代码风格，并随安装包提供了一个名为 Gofmt 的工具，这个工具可以帮助你将代码自动格式化为约定的风格。</p>
<p>Gofmt 是 Go 语言在解决规模化（scale）问题上的一个最佳实践，并成为了 Go 语言吸引其他语言开发者的一大卖点。很多其他主流语言也在效仿 Go 语言推出自己的 format 工具，比如：Java formatter、Clang formatter、Dartfmt 等。<strong>因此，作为 Go 开发人员，请在提交你的代码前使用 Gofmt 格式化你的 Go 源码。</strong></p>
<p>好，回到正题，我们再来看一看 main 函数体中的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">&quot;hello, world&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>这一行代码已经完成了整个示例程序的所有工作了：将字符串输出到终端的标准输出（stdout）上。不过这里还有几个需要你注意的细节。</p>
<p><strong>注意点 1：标准 Go 代码风格使用 Tab 而不是空格来实现缩进的</strong>，当然这个代码风格的格式化工作也可以交由 gofmt 完成。</p>
<p><strong>注意点 2：</strong>我们调用了一个名为 Println 的函数，这个函数位于 Go 标准库的 fmt 包中。为了在我们的示例程序中使用 fmt 包定义的 Println 函数，我们其实做了两步操作。</p>
<p>第一步是在源文件的开始处通过 import 声明导入 fmt 包的包路径：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br></pre></td></tr></table></figure>
<p>第二步则是在 main 函数体中，通过 fmt 这个限定标识符（Qualified Identifier）调用 Println 函数。虽然两处都使用了“fmt”这个字面值，但在这两处“fmt”字面值所代表的含义却是不一样的：</p>
<ul>
<li>import “fmt” 一行中“fmt”代表的是包的导入路径（Import），它表示的是标准库下的 fmt 目录，整个 import 声明语句的含义是导入标准库 fmt 目录下的包；</li>
<li>fmt.Println 函数调用一行中的“fmt”代表的则是包名。</li>
</ul>
<p>通常导入路径的最后一个分段名与包名是相同的，这也很容易让人误解 import 声明语句中的“fmt”指的是包名，其实并不是这样的。</p>
<p>main 函数体中之所以可以调用 fmt 包的 Println 函数，还有最后一个原因，那就是 Println 函数名的首字母是大写的。在 Go 语言中，只有首字母为大写的标识符才是导出的（Exported），才能对包外的代码可见；如果首字母是小写的，那么就说明这个标识符仅限于在声明它的包内可见。</p>
<p>另外，在 Go 语言中，main 包是不可以像标准库 fmt 包那样被导入（Import）的，如果导入 main 包，在代码编译阶段你会收到一个 Go 编译器错误：import “xx/main” is a program, not an importable package。</p>
<p><strong>注意点 3：</strong>我们还是回到 main 函数体实现上，把关注点放在传入到 Println 函数的字符串“hello, world”上面。你会发现，<strong>我们传入的字符串也就是我们执行程序后在终端的标准输出上看到的字符串。</strong></p>
<p>这种“所见即所得”得益于 Go 源码文件本身采用的是 Unicode 字符集，而且用的是 UTF-8 标准的字符编码方式，这与编译后的程序所运行的环境所使用的字符集和字符编码方式是一致的。</p>
<p>这里，即便我们将代码中的”hello, world”换成中文字符串“你好，世界”，像下面这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;你好，世界&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们依旧可以在终端的标准输出上看到正确的输出。</p>
<p><strong>最后，不知道你有没有发现，我们整个示例程序源码中，都没有使用过分号来标识语句的结束，这与 C、C++、Java 那些传统编译型语言好像不太一样呀？</strong></p>
<p>不过，其实 Go 语言的正式语法规范是使用分号“;”来做结尾标识符的。那为什么我们很少在 Go 代码中使用和看到分号呢？这是因为，大多数分号都是可选的，常常被省略，不过在源码编译时，Go 编译器会自动插入这些被省略的分号。</p>
<p>我们给上面的“hello，world”示例程序加上分号也是完全合法的，是可以直接通过 Go 编译器编译并正常运行的。不过，gofmt 在按约定格式化代码时，会自动删除这些被我们手工加入的分号的。</p>
<p>在分析完这段代码结构后，我们来讲一下 Go 语言的编译。虽然刚刚你应该已经运行过“hello, world”这个示例程序了，在这过程中，有一个重要的步骤——<strong>编译</strong>，现在我就带你来看看 Go 语言中程序是怎么进行编译的。</p>
<h2 id="Go-语言中程序是怎么编译的？"><a href="#Go-语言中程序是怎么编译的？" class="headerlink" title="Go 语言中程序是怎么编译的？"></a>Go 语言中程序是怎么编译的？</h2><p>你应该也注意到了，刚刚我在运行”hello, world”程序之前，输入了 go build 命令，还有它附带的源文件名参数来编译它：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build main.go</span><br></pre></td></tr></table></figure>
<p>假如你曾经有过 C/C++ 语言的开发背景，那么你就会发现这个步骤与 gcc 或 clang 编译十分相似。一旦编译成功，我们就会获得一个二进制的可执行文件。在 Linux 系统、macOS 系统，以及 Windows 系统的 PowerShell 中，我们可以通过输入下面这个 ls 命令看到刚刚生成的可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br><span class="line">main*    main.go</span><br></pre></td></tr></table></figure>
<p>上面显示的文件里面有我们刚刚创建的、以.go 为后缀的源代码文件，还有刚生成的可执行文件（Windows 系统下为 main.exe，其余系统下为 main）。</p>
<p>如果你之前更熟悉某种类似于 Ruby、Python 或 JavaScript 之类的动态语言，你可能还不太习惯在运行之前需要先进行编译的情况。<strong>Go 是一种编译型语言，这意味着只有你编译完 Go 程序之后，才可以将生成的可执行文件交付于其他人，并运行在没有安装 Go 的环境中。</strong></p>
<p>而如果你交付给其他人的是一份.rb、.py 或.js 的动态语言的源文件，那么他们的目标环境中就必须要拥有对应的 Ruby、Python 或 JavaScript 实现才能解释执行这些源文件。</p>
<p>当然，Go 也借鉴了动态语言的一些对开发者体验较好的特性，比如基于源码文件的直接执行，Go 提供了 run 命令可以直接运行 Go 源码文件，比如我们也可以使用下面命令直接基于 main.go 运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br><span class="line">hello, world</span><br></pre></td></tr></table></figure>
<p>当然像 go run 这类命令更多用于开发调试阶段，真正的交付成果还是需要使用 go build 命令构建的。</p>
<p>但是在我们的生产环境里，Go 程序的编译往往不会像我们前面，基于单个 Go 源文件构建类似“hello，world”这样的示例程序那么简单。越贴近真实的生产环境，也就意味着项目规模越大、协同人员越多，项目的依赖和依赖的版本都会变得复杂。</p>
<p><strong>那在我们更复杂的生产环境中，go build 命令也能圆满完成我们的编译任务吗？</strong>我们现在就来探讨一下。</p>
<h2 id="复杂项目下-Go-程序的编译是怎样的"><a href="#复杂项目下-Go-程序的编译是怎样的" class="headerlink" title="复杂项目下 Go 程序的编译是怎样的"></a>复杂项目下 Go 程序的编译是怎样的</h2><p>我们还是直接上项目吧，给 go build 一个机会，看看它的复杂依赖管理到底怎么样。</p>
<p>现在我们创建一个新项目“hellomodule”，在新项目中我们将使用两个第三方库，zap 和 fasthttp，给 go build 的构建过程增加一些难度。和“hello，world”示例一样，我们通过下面命令创建“hellomodule”项目：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/goprojects</span><br><span class="line">mkdir hellomodule</span><br><span class="line">cd hellomodule</span><br></pre></td></tr></table></figure>
<p>接着，我们在“hellomodule“下创建并编辑我们的示例源码文件：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;github.com/valyala/fasthttp&quot;</span></span><br><span class="line">  <span class="string">&quot;go.uber.org/zap&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logger *zap.Logger</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  logger, _ = zap.NewProduction()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fastHTTPHandler</span><span class="params">(ctx *fasthttp.RequestCtx)</span></span> &#123;</span><br><span class="line">  logger.Info(<span class="string">&quot;hello, go module&quot;</span>, zap.ByteString(<span class="string">&quot;uri&quot;</span>, ctx.RequestURI()))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fasthttp.ListenAndServe(<span class="string">&quot;:8081&quot;</span>, fastHTTPHandler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个示例创建了一个在 8081 端口监听的 http 服务，当我们向它发起请求后，这个服务会在终端标准输出上输出一段访问日志。</p>
<p>你会看到，和“hello，world“相比，这个示例显然要复杂许多。但不用担心，你现在大可不必知道每行代码的功用，你只需要我们在这个稍微有点复杂的示例中引入了两个第三方依赖库，zap 和 fasthttp 就可以了。</p>
<p>我们尝试一下使用编译“hello，world”的方法来编译“hellomodule”中的 main.go 源文件，go 编译器的输出结果是这样的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go build main.go</span><br><span class="line">main.go:4:2: no required module provides package github.com/valyala/fasthttp: go.mod file not found in current directory or any parent directory; see &#x27;go help modules&#x27;</span><br><span class="line">main.go:5:2: no required module provides package go.uber.org/zap: go.mod file not found in current directory or any parent directory; see &#x27;go help modules&#x27;</span><br></pre></td></tr></table></figure>
<p>看这结果，这回我们运气似乎不佳，main.go 的编译失败了！</p>
<p>从编译器的输出来看，go build 似乎在找一个名为 go.mod 的文件，来解决程序对第三方包的依赖决策问题。</p>
<p><strong>好了，我们也不打哑谜了，是时候让 Go module 登场了！</strong></p>
<p>Go module 构建模式是在 Go 1.11 版本正式引入的，为的是彻底解决 Go 项目复杂版本依赖的问题，在 Go 1.16 版本中，Go module 已经成为了 Go 默认的包依赖管理机制和 Go 源码构建机制。</p>
<p>Go Module 的核心是一个名为 go.mod 的文件，在这个文件中存储了这个 module 对第三方依赖的全部信息。接下来，我们就通过下面命令为“hello，module”这个示例程序添加 go.mod 文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">go mod init github.com/bigwhite/hellomodule</span><br><span class="line">go: creating new go.mod: module github.com/bigwhite/hellomodule</span><br><span class="line">go: to add module requirements and sums:</span><br><span class="line">  go mod tidy</span><br></pre></td></tr></table></figure>
<p>你会看到，go mod init 命令的执行结果是在当前目录下生成了一个 go.mod 文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat go.mod</span><br><span class="line">module github.com/bigwhite/hellomodule</span><br><span class="line"></span><br><span class="line">go 1.16</span><br></pre></td></tr></table></figure>
<p>其实，一个 module 就是一个包的集合，这些包和 module 一起打版本、发布和分发。go.mod 所在的目录被我们称为它声明的 module 的根目录。</p>
<p>不过呢，这个时候的 go.mod 文件内容还比较简单，第一行内容是用于声明 module 路径（module path）的。而且，module 隐含了一个命名空间的概念，module 下每个包的导入路径都是由 module path 和包所在子目录的名字结合在一起构成。</p>
<p>比如，如果 hellomodule 下有子目录 pkg/pkg1，那么 pkg1 下面的包的导入路径就是由 module path（github.com/bigwhite/hellomodule）和包所在子目录的名字（pkg/pkg1）结合而成，也就是 github.com/bigwhite/hellomodule/pkg/pkg1。</p>
<blockquote>
<p>如果 路径和包名不一样， path: apath, package: apack 那么使用的时候是</p>
<p> import “apath” </p>
<p>apack.Print()</p>
</blockquote>
<p>另外，go.mod 的最后一行是一个 Go 版本指示符，用于表示这个 module 是在某个特定的 Go 版本的 module 语义的基础上编写的。</p>
<p><strong>有了 go.mod 后，是不是我们就可以构建 hellomodule 示例了呢？</strong></p>
<p>来试试看！我们执行一下构建，Go 编译器输出结果是这样的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">go build main.go</span><br><span class="line">main.go:4:2: no required module provides package github.com/valyala/fasthttp; to add it:</span><br><span class="line">  go get github.com/valyala/fasthttp</span><br><span class="line">main.go:5:2: no required module provides package go.uber.org/zap; to add it:</span><br><span class="line">  go get go.uber.org/zap</span><br></pre></td></tr></table></figure>
<p>你会看到，Go 编译器提示源码依赖 fasthttp 和 zap 两个第三方包，但是 go.mod 中没有这两个包的版本信息，我们需要按提示手工添加信息到 go.mod 中。</p>
<p>这个时候，除了按提示手动添加外，我们也可以使用 go mod tidy 命令，让 Go 工具自动添加：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">go mod tidy       </span><br><span class="line">go: downloading go.uber.org/zap v1.18.1</span><br><span class="line">go: downloading github.com/valyala/fasthttp v1.28.0</span><br><span class="line">go: downloading github.com/andybalholm/brotli v1.0.2</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure>
<p>从输出结果中，我们看到 Go 工具不仅下载并添加了 hellomodule 直接依赖的 zap 和 fasthttp 包的信息，还下载了这两个包的相关依赖包。go mod tidy 执行后，我们 go.mod 的最新内容变成了这个样子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module github.com/bigwhite/hellomodule</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.16</span></span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">  github.com/valyala/fasthttp v1<span class="number">.28</span><span class="number">.0</span></span><br><span class="line">  <span class="keyword">go</span>.uber.org/zap v1<span class="number">.18</span><span class="number">.1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这个时候，go.mod 已经记录了 hellomodule 直接依赖的包的信息。不仅如此，hellomodule 目录下还多了一个名为 go.sum 的文件，这个文件记录了 hellomodule 的直接依赖和间接依赖包的相关版本的 hash 值，用来校验本地包的真实性。在构建的时候，如果本地依赖包的 hash 值与 go.sum 文件中记录的不一致，就会被拒绝构建。</p>
<p>有了 go.mod 以及 hellomodule 依赖的包版本信息后，我们再来执行构建：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">go build main.go</span><br><span class="line">ls</span><br><span class="line">go.mod    go.sum    main*    main.go</span><br></pre></td></tr></table></figure>
<p>这次我们成功构建出了可执行文件 main，运行这个文件，新开一个终端窗口，在新窗口中使用 curl 命令访问该 http 服务：curl localhost:8081/foo/bar，我们就会看到服务端输出如下日志：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./main</span><br><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;ts&quot;:1626614126.9899719,&quot;caller&quot;:&quot;hellomodule/main.go:15&quot;,&quot;msg&quot;:&quot;hello, go module&quot;,&quot;uri&quot;:&quot;/foo/bar&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>这下，我们的“ hellomodule”程序可算创建成功了。我们也看到使用 Go Module 的构建模式，go build 完全可以承担其构建规模较大、依赖复杂的 Go 项目的重任。还有更多关于 Go Module 的内容，我会在第 7 节课再详细跟你讲解。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到这里，我们终于亲手编写完成了 Go 语言的第一个程序“hello, world”，我们终于知道一个 Go 程序长成啥样子了，这让我们在自己的 Go 旅程上迈出了坚实的一步！</p>
<p>在这一节课里，我们通过 helloworld 示例程序，了解了一个 Go 程序的源码结构与代码风格自动格式化的约定。</p>
<p>我希望你记住这几个要点：</p>
<ul>
<li>Go 包是 Go 语言的基本组成单元。一个 Go 程序就是一组包的集合，所有 Go 代码都位于包中。</li>
<li>Go 源码可以导入其他 Go 包，并使用其中的导出语法元素，包括类型、变量、函数、方法等，而且，main 函数是整个 Go 应用的入口函数。</li>
<li>Go 源码需要先编译，再分发和运行。如果是单 Go 源文件的情况，我们可以直接使用 go build 命令 +Go 源文件名的方式编译。不过，对于复杂的 Go 项目，我们需要在 Go Module 的帮助下完成项目的构建。</li>
</ul>
<p>最后，我们结合 hellomodule 示例初步学习了一个基于 Go Module 构建模式编写和构建更大规模 Go 程序的步骤并介绍了 Go Module 涉及到的各种概念。而且，Go Module 机制日渐成熟，我希望你学会基于 Go Module 构建 Go 应用。关于 Go Module 构建模式，我们还会在后面的讲解中详细介绍。</p>
<h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="如何import自己在本地创建的module，在这个module还没有发布到GitHub的情况下？"><a href="#如何import自己在本地创建的module，在这个module还没有发布到GitHub的情况下？" class="headerlink" title="如何import自己在本地创建的module，在这个module还没有发布到GitHub的情况下？"></a>如何import自己在本地创建的module，在这个module还没有发布到GitHub的情况下？</h3><p>go module机制在您提到的工作场景下目前的体验做的还不够好。</p>
<p>在Go 1.17版本及之前版本的解决方法是使用go mod的replace指示符(directive)。假如你的module a要import的module b将发布到github.com/user/repo中，那么你可以手动在module的go.mod中的require块中手工加上一条：</p>
<p> require github.com/user/repo v1.0.0 </p>
<p>注意v1.0.0这个版本号是一个临时的版本号。 然后在module a的go.mod中使用replace将上面对module b的require替换为本地的module b:</p>
<p> replace github.com/user/repo v1.0.0 =&gt; module b本地路径 </p>
<p>这样go命令就会使用你本地正在开发、尚未提交github的module b了。 </p>
<h3 id="配置国内镜像代理（使用阿里云镜像）"><a href="#配置国内镜像代理（使用阿里云镜像）" class="headerlink" title="配置国内镜像代理（使用阿里云镜像）"></a>配置国内镜像代理（使用阿里云镜像）</h3><p>go env -w GOPROXY=<a target="_blank" rel="noopener" href="https://mirrors.aliyun.com/goproxy/">https://mirrors.aliyun.com/goproxy/</a> </p>
<p>验证 go env|grep GOPROXY</p>
<h3 id="go-mod-tidy-命令后，下载的包在哪？在Go语言安装路径的src文件夹中？还是在哪"><a href="#go-mod-tidy-命令后，下载的包在哪？在Go语言安装路径的src文件夹中？还是在哪" class="headerlink" title="go mod tidy 命令后，下载的包在哪？在Go语言安装路径的src文件夹中？还是在哪?"></a>go mod tidy 命令后，下载的包在哪？在Go语言安装路径的src文件夹中？还是在哪?</h3><p>go mod tidy下载的第三方包一般在$GOPATH/pkg/mod下面。如果没有设置GOPATH环境变量，其默认值为你的home路径下的go文件夹。这样第三方包就在go文件夹的pkg/mod下面。</p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>oneyoung
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://oneyoung.top/%E5%88%9D%E7%AA%A5%E9%97%A8%E5%BE%84%EF%BC%9A%E4%B8%80%E4%B8%AAGo%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%93%E6%9E%84%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F/" title="初窥门径：一个Go程序的结构是怎样的？">https://oneyoung.top/初窥门径：一个Go程序的结构是怎样的？/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/%E9%85%8D%E5%A5%BD%E7%8E%AF%E5%A2%83%EF%BC%9A%E9%80%89%E6%8B%A9%E4%B8%80%E7%A7%8D%E6%9C%80%E9%80%82%E5%90%88%E4%BD%A0%E7%9A%84Go%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/" rel="prev" title="配好环境：选择一种最适合你的Go安装方法">
      <i class="fa fa-chevron-left"></i> 配好环境：选择一种最适合你的Go安装方法
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E2%80%9Chello%EF%BC%8Cworld%E2%80%9D%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.</span> <span class="nav-text">创建“hello，world”示例程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E2%80%9Chello%EF%BC%8Cworld%E2%80%9D%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="nav-number">2.</span> <span class="nav-text">创建“hello，world”文件夹</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E5%B9%B6%E8%BF%90%E8%A1%8C%E7%AC%AC%E4%B8%80%E4%B8%AA-Go-%E7%A8%8B%E5%BA%8F"><span class="nav-number">3.</span> <span class="nav-text">编写并运行第一个 Go 程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E2%80%9Chello%EF%BC%8Cworld%E2%80%9D%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">4.</span> <span class="nav-text">“hello，world”示例程序的结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Go-%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E7%BC%96%E8%AF%91%E7%9A%84%EF%BC%9F"><span class="nav-number">5.</span> <span class="nav-text">Go 语言中程序是怎么编译的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E9%A1%B9%E7%9B%AE%E4%B8%8B-Go-%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84"><span class="nav-number">6.</span> <span class="nav-text">复杂项目下 Go 程序的编译是怎样的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">7.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FAQ"><span class="nav-number">8.</span> <span class="nav-text">FAQ</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95import%E8%87%AA%E5%B7%B1%E5%9C%A8%E6%9C%AC%E5%9C%B0%E5%88%9B%E5%BB%BA%E7%9A%84module%EF%BC%8C%E5%9C%A8%E8%BF%99%E4%B8%AAmodule%E8%BF%98%E6%B2%A1%E6%9C%89%E5%8F%91%E5%B8%83%E5%88%B0GitHub%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%9F"><span class="nav-number">8.1.</span> <span class="nav-text">如何import自己在本地创建的module，在这个module还没有发布到GitHub的情况下？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E4%BB%A3%E7%90%86%EF%BC%88%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91%E9%95%9C%E5%83%8F%EF%BC%89"><span class="nav-number">8.2.</span> <span class="nav-text">配置国内镜像代理（使用阿里云镜像）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#go-mod-tidy-%E5%91%BD%E4%BB%A4%E5%90%8E%EF%BC%8C%E4%B8%8B%E8%BD%BD%E7%9A%84%E5%8C%85%E5%9C%A8%E5%93%AA%EF%BC%9F%E5%9C%A8Go%E8%AF%AD%E8%A8%80%E5%AE%89%E8%A3%85%E8%B7%AF%E5%BE%84%E7%9A%84src%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%AD%EF%BC%9F%E8%BF%98%E6%98%AF%E5%9C%A8%E5%93%AA"><span class="nav-number">8.3.</span> <span class="nav-text">go mod tidy 命令后，下载的包在哪？在Go语言安装路径的src文件夹中？还是在哪?</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">oneyoung</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/oneyoungg" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;oneyoungg" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">oneyoung</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
